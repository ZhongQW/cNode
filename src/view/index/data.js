const data = {"success":true,"data":[{"id":"5a37c17dd92f2f5b185acfc4","author_id":"4efc278525fa69ac6900000f","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://dn-cnode.qbox.me/FuvPQvPz9RBxT07UrcBumIxmg-8G\" alt=\"1.png\"></p>\n<h2>大会简介</h2>\n<p>SEE = Seeking Experience &amp; Engineering，意为探索用户体验与工程实践，由蚂蚁金服集团每年举办 1-2 次，包括专业分享、产品展台、Workshop 等内容。希望通过 SEE Conf，能与业界同行一起分享交流体验科技的当前进展，一起探讨切磋体验科技的未来发展，共同努力促进体验设计与技术的开放，让生态繁荣共赢。</p>\n<p>首届 <a href=\"https://seeconf.alipay.com/\">SEE Conf</a> 将于 2018.01.06 在美丽的浙江杭州举办，届时我们将邀请数百位来自前端、设计、产品等领域的英才，围绕「极致用户体验」和「最佳工程实践」两大主题进行探讨交流。</p>\n<h2>特邀嘉宾</h2>\n<ul>\n<li>蚂蚁金服副总裁：胡喜 (阿玺)</li>\n<li>美团高级技术总监 ／ 业务负责人：刘平川 (rank)</li>\n<li>饿了么大前端部门负责人：林建锋 (sofish)</li>\n<li>百姓网资深前端架构师：贺师俊 (hax)</li>\n<li>豆瓣资深前端架构师：张克军 (kejun）</li>\n<li>钉钉资深技术专家：石玉磊 (佩玉)</li>\n<li>支付宝 UED 负责人：梁山鹰 (隼飞)</li>\n<li>蚂蚁金服体验技术部负责人：王保平 (玉伯)</li>\n</ul>\n<h2>会议日程</h2>\n<p>大会于 2018.01.06 正式召开，当天日程如下：</p>\n<ul>\n<li>09:00 - 09:15：开幕致辞</li>\n<li>09:15 - 10:00：蚂蚁中台设计体系 —— Ant Design 3.0 背后的故事</li>\n<li>10:00 - 10:45：Developer Experience First —— TWA 的理念与实践</li>\n<li>10:45 - 11:30：惊艳的互联网互动体验 —— AntG</li>\n<li>11:30 - 13:30：午间休息</li>\n<li>13:30 - 14:15：TECH 模型：企业级中后台产品体验度量探索</li>\n<li>14:15 - 15:00：AntV，返璞归真幻化万千可视化表达</li>\n<li>15:00 - 15:45：蚂蚁开发者工具，服务蚂蚁生态的移动研发 IDE</li>\n<li>15:45 - 16:30：轻推转型之门：Ant Design Pro 在企业级产品的探索</li>\n<li>16:30 - 16:45：从前端技术到体验科技，暨蚂蚁体验云起航</li>\n<li>16:45 - 17:15：圆桌 —— 体验科技的发展及未来</li>\n</ul>\n<h2>大会看点</h2>\n<p>这是蚂蚁金服体验科技首次对外发声，有大家熟悉的各个明星产品。有一个产品，过去 14 个月在 GitHub 的 star 数从 4k 飙升至 2w+，\n这是蚂蚁设计语言 <a href=\"https://ant.design/index-cn\">Ant Design</a>，她是在怎样的业务土壤与团队文化中成长起来的？背后有着怎样的故事？还有一个产品，刚一开源就得到世界级计算机科学家 <a href=\"https://www.cs.uic.edu/~wilkinson/\">Leland Wilkinson</a> 的肯定，这款技术产品是 <a href=\"https://github.com/antvis/g2\">G2</a>，其背后更大的蚂蚁可视化 <a href=\"https://antv.alipay.com/zh-cn/index.html\">AntV</a> 体系是本着怎样的初心在坚持前行？回顾过往，基于 Node.js 的前后端分层这几年在阿里经历了怎样的风雨？什么是 BFF（Backend For Frontend）架构？更进一步的 <strong>TWA</strong>（Techless Web App）架构是为了解决什么问题？为企业级框架和应用而生的 <a href=\"https://eggjs.org/\">Egg.js</a> 将走向何方？</p>\n<p>除此之外，还有最前沿的移动研发 IDE 技术和企业级产品体验度量的探索分享，更有未曾对外曝光，但已适配了千万机型的 Web 互动图形技术 AntG 将首度登台。从前端技术到体验科技，玉伯这位前端圈里的传奇黑侠将为我们讲述的“<strong>蚂蚁体验云</strong>”究竟是什么。</p>\n<p><img src=\"https://gw.alipayobjects.com/zos/rmsportal/ODVJIUEvmuKCwXqqJPfo.jpg\" alt></p>\n<p>技术大会不光能听到干货，还能面基好友结交各路大神。除了议程提到的众多明星嘉宾，从目前报名中已经发现数十位重量级人物，不乏知名公司的产品、设计总监，架构师，新锐公司的 CXO 和领域新秀。</p>\n<p>另外，蚂蚁金服是个藏龙卧虎的地方，有知名博主，也有知乎网红，有 Node.js、Ruby 等各个技术社区的大拿，还有仙剑主程、艺术插画大师，图形图像、数据可视化专家也会出没会场，有的还当起了会场志愿者在门口热切地期待着你的到来。他们会游走在会场与各个展台之间，也许就坐在你身边，这是面基好友结交大神的好时候，机会难得。</p>\n<p><img src=\"https://gw.alipayobjects.com/zos/rmsportal/DdjWkCAawyOMhFnLpGLK.jpg\" alt></p>\n<h2>如何报名</h2>\n<p>访问 <a href=\"https://seeconf.alipay.com/\">SEE Conf · 蚂蚁金服体验科技大会</a>，点击「立即报名」按钮</p>\n<p>支付宝扫描下方二维码</p>\n<p><img src=\"https://gw.alipayobjects.com/zos/rmsportal/gmcvvumwUehXYbTPBPno.gif\" alt></p>\n</div>","title":"首届蚂蚁金服体验科技大会","last_reply_at":"2018-01-21T09:51:48.428Z","good":false,"top":true,"reply_count":36,"visit_count":7333,"create_at":"2017-12-18T13:24:13.334Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars0.githubusercontent.com/u/156269?v=4&s=120"}},{"id":"5a2403226190c8912ebaceeb","author_id":"4f447c2f0a8abae26e01b27d","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FhSNYCv6Ab9wzT6aUSfKLa0GtP4w\" alt=\"image.png\"></p>\n<blockquote>\n<p>原文地址：知乎专栏 <a href=\"https://zhuanlan.zhihu.com/p/31640541\">https://zhuanlan.zhihu.com/p/31640541</a></p>\n</blockquote>\n<p>给大家介绍下，Egg 2.0 正式版，今天 12.3 冒泡啦，距 3.21 的 <a href=\"https://zhuanlan.zhihu.com/p/25860846\">Egg 1.0 版本</a> 时隔 8 个月。</p>\n<p><img src=\"//dn-cnode.qbox.me/FrC_ZbrhyLkhVIquPOsMqPhvqsHX\" alt=\"image.png\"></p>\n<blockquote>\n<p><a href=\"https://eggjs.org/\">Egg</a> 是阿里 Node.js 的核心基础框架，面向『企业级的 Web 基础框架』这个领域，提供了「微内核 + 插件机制 + 框架定制能力」，完美达成生态共建和差异化定制的平衡点。<br>\n既适合个人小项目快速开发，也适合团队架构师基于自身的技术架构在 Egg 基础上扩展出适合特定团队业务场景的框架。<br>\n它沉淀自阿里在各行各业不同领域的大规模工程实践经验，稳定支撑了多年天猫双11大促，顶级流量压力。</p>\n</blockquote>\n<h2>2.0 特性</h2>\n<ul>\n<li>基于 Koa 2.x\n<ul>\n<li>异步解决方案直接基于 Async Function 。</li>\n<li>去除 co 兼容后<a href=\"https://github.com/eggjs/egg/wiki/co-vs-async\">堆栈信息更清晰</a>。</li>\n</ul>\n</li>\n<li>框架层优化带来 <a href=\"https://eggjs.github.io/benchmark/plot/\">30% 左右的性能提升</a>，不含 Node 8 带来的提升。</li>\n<li>为了方便开发者快速升级，保持了对 Egg 1.x 以及 generator function 的兼容。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fuf5DkXMxM7wfClcN6B6LzX5d18Q\" alt=\"image.png\"></p>\n<h2>如何升级</h2>\n<p><strong><a href=\"https://eggjs.org/\">Egg</a> 的理念之一是渐进式增强，故我们为开发者提供渐进升级的体验。</strong></p>\n<ol>\n<li>Node.js 使用最新的 LTS 版本（&gt;=8.9.0）。</li>\n<li>修改 package.json 中 egg 的依赖为 ^2.0.0。</li>\n<li>检查相关插件是否发布新版本（可选）。</li>\n<li>重新安装依赖，跑单元测试。</li>\n</ol>\n<p><strong>搞定！几乎不需要修改任何一行代码，就已经完成了升级。</strong></p>\n<p>这得益于 Egg 对 1.x 的兼容，但为了更好的统一代码风格，以及更佳的性能和错误堆栈，我们建议开发者参考 <a href=\"https://eggjs.org/zh-cn/migration.html\">升级指南</a> 进一步升级。</p>\n<h2>未来规划</h2>\n<p>如您所知，Egg 采用的是 <strong>『微内核 + 插件 + 上层框架』</strong> 模式。</p>\n<p>其中微内核经过 3 年 4 个版本，以及在阿里的大规模应用，已经打磨的非常稳定。</p>\n<p>接下来我们的<strong>重心主要在开发者体验方面的优化</strong>，包括：</p>\n<ul>\n<li>更好的开发者体验，包括 TypeScript，开发者工具，IDE 工具等方面。</li>\n<li>社区扶持\n<ul>\n<li>协助业界的前端团队，打造适合特定团队业务场景的上层框架，欢迎勾搭。</li>\n<li>分享我们在团队、协作、规范化等方面的经验。</li>\n<li>分享在 Docker，GraphQL，SSR 等方面的探索和最佳实践分享。</li>\n</ul>\n</li>\n<li>国际化，官网和<a href=\"https://github.com/eggjs/egg/issues/363\">文档翻译</a>等。</li>\n</ul>\n<p>同时，我们也欢迎社区更多的<a href=\"https://github.com/orgs/eggjs/projects\">参与</a>，一起打造更完善的生态。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fg_WHGNC13j2azgEWb-ONk5whle5\" alt=\"image.png\"></p>\n<h2>我们这一年</h2>\n<p>截止至今天(2017-12-03)：</p>\n<ul>\n<li><strong>GitHub 5.6k star</strong>，555 forks，npm 月下载量 11,140 (不含阿里内网数据)。</li>\n<li>从 1.0 到 2.0，我们一共发布了 <a href=\"https://github.com/eggjs/egg/releases\">18 个版本</a>，处理了 820 个 issue，收到了 500+ (主库 272) 个 Pull Request 。</li>\n<li>开发者体验方面的优化包括：<a href=\"https://eggjs.org/zh-cn/core/development.html#%E4%BD%BF%E7%94%A8-egg-bin-%E8%B0%83%E8%AF%95\">断点调试代理</a>，<a href=\"https://eggjs.org/zh-cn/core/development.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">单元测试+覆盖率</a>，<a href=\"https://eggjs.org/zh-cn/core/deployment.html#%E9%83%A8%E7%BD%B2\">部署工具</a>，TypeScript 支持，<a href=\"https://github.com/eggjs/vscode-eggjs\">VSCode 插件</a>，文档优化等等。</li>\n</ul>\n<p><strong>社区方面：</strong></p>\n<ul>\n<li>来自 BAT，丁香园，全民直播等多家兄弟公司的反馈和插件回馈。</li>\n<li>来自 <a href=\"https://github.com/eggjs/egg/network/dependents\">GitHub Dependents</a> 的统计：992 Repositories, 231 Packages</li>\n<li><a href=\"https://npms.io/search?q=egg-\">NPM 搜索结果</a>超过 400 个。</li>\n<li>上层框架：\n<ul>\n<li><a href=\"https://github.com/alibaba/beidou\">北斗</a> - Isomorphic framework for server-rendered React apps</li>\n<li><a href=\"https://github.com/avetjs/avet\">avet</a> - A very comfortable framework for writing isomorphic applications</li>\n</ul>\n</li>\n<li>如果你有好的分享，PR 传送门：<a href=\"https://github.com/eggjs/awesome-egg\">awesome-egg</a></li>\n</ul>\n<p><strong>趣味数据：</strong></p>\n<ul>\n<li>官网访问量中，Mac 占 47% → 这比例挺高的，看来 Node 程序猿都很幸福。</li>\n<li>周末的访问量约为平时的 1/3 → 看来 Node 程序猿周末加班少。（滑稽</li>\n<li>官网访问来源：站内，直链，外链各 30% 多，来自搜索引擎的较少。</li>\n</ul>\n<p><strong>分享交流：</strong></p>\n<ul>\n<li>在 <a href=\"http://2017.jsdc.tw/\">台灣 JSDC2017 開發者年會</a> 和 <a href=\"http://2017.imweb.io/index.html#schedule\">腾讯IMWebConf</a> 分享了『<a href=\"https://github.com/atian25/blog/raw/master/assets/files/Egg%20%26%20Node.js%20%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%9D%8A%E8%B5%B0%E5%90%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91.pdf\">Egg &amp; Node.js 从小工坊走向企业级开发</a>』</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/FgFUrGpNw07LKQPYzGgZp64j7CZH\" alt=\"image.png\"></p>\n<ul>\n<li>Node TSC @张秋怡 在 <a href=\"https://nina17.sched.com/event/Atii/nodejs-at-alibaba-a-joyee-cheung-alibaba-cloud\">Node Interactive North America 2017</a> 和 <a href=\"http://nodefest.jp/2017/schedule.html#joyee\">東京Node学園祭2017</a> 分享了『<a href=\"https://github.com/joyeecheung/talks/blob/master/node_fest_2017/nodejs_at_alibaba_tokyo.pdf\">Node.js at Alibaba</a>』。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fl5IyrfAMzQ49Uz3eQ67i2FLL09H\" alt=\"image.png\"></p>\n<ul>\n<li><a href=\"/user/ngot\">@ngot</a> 在 <a href=\"https://www.bagevent.com/event/751307\">Node Party</a> 分享了『<a href=\"https://github.com/Hangzhou-Node-Party/Node-Party/blob/master/2017-08-19/Egg.js%E5%9C%A8%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9B%86%E5%9B%A2%E7%9A%84%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%BF%90%E7%94%A8.pdf\">Egg.js 在阿里巴巴集团的实践运用</a>』</li>\n<li>@姜天意 在 <a href=\"http://2017.imweb.io/index.html#schedule\">腾讯IMWebConf</a> 分享了 『<a href=\"https://github.com/jtyjty99999/share/blob/master/security%20risk%20in%20node%20web.pdf\">脆弱的 Node.js</a>』</li>\n</ul>\n<h2>写在最后</h2>\n<p>开源，痛并快乐着。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fiamh5LNYR3e2E0HtdhrO3sVfHrs\" alt=\"image.png\"></p>\n</div>","title":"企业级 Node.js 框架 Egg 发布 2.0，性能提升 30%，拥抱 Async","last_reply_at":"2018-01-19T03:55:37.279Z","good":true,"top":true,"reply_count":97,"visit_count":15353,"create_at":"2017-12-03T13:58:58.901Z","author":{"loginname":"atian25","avatar_url":"https://avatars1.githubusercontent.com/u/227713?v=3&s=120"}},{"id":"5a54a8a4afa0a121784a8ab0","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><p>很抱歉在首届蚂蚁体验科技 SEE Conf 大会上，给大家讲得有点磕绊不太清楚。今天写下来行诸文字，希望一些思考能与大家进一步交流。（设计师朋友可以跳过前端技术部分，直接看后面章节）</p>\n<h2>什么是前端技术</h2>\n<p>第一次接触前端开发是 2002 年大学期间，转眼 15 年多。这些年一直在思考一个问题：究竟什么是前端技术？很长很长一段时间，前端技术的定义非常清晰，就是浏览器端的 HTML、CSS、JS 技术。我们用这些技术做出各种各样的页面，我们是离用户最近的程序员。</p>\n<p><img src=\"//dn-cnode.qbox.me/FuTZzCUKkL_OGOsmrXbXvcqalO-D\" alt=\"v2-356e4bb976792ec0c2ae166405e4b502_hd.jpg\"></p>\n<p>记得 2009 年开始接触 Node，很快前端技术开始爆炸性增长。最开始的变化，是前端压缩工具从基于 Java 的 YUI Compressor 开始切换到基于 Node 实现的 UglifyJS 等工具。除了前端工具上的一路狂奔，在服务端领域也出现了 Express 等框架，前端开始通过 Node 完成服务端模板甚至整个 MVC 层的开发。在蚂蚁金服，服务端层我们更多把 Node 定位为 BFF 层实现，BFF 是 Backend For Frontend 的缩写，翻译成用户体验适配层。</p>\n<p>BFF 模式下，整体分工很清晰，后端通过 Java 等语言负责服务实现，理想情况下给前端提供的是基于领域模型的 RPC 接口，前端则在 BFF 层直接调用服务端 RPC 接口拿到数据，按需加工消费数据，并实现人机交互。基于 BFF 模式的研发，很适合拥有前端技术背景的全栈型工程师。这种模式的好处很明显，后端可以专注于业务领域，更多从领域模型的视角去思考问题，页面视角的数据则交给前端型全栈工程师去搞定。领域模型与页面数据是两种思维模式，通过 BFF 可以很好地解耦开，让彼此更专业高效。</p>\n<p>除了服务端的渗透，从 2013 年开始，阿里开始无线 ALL IN 战略，这对前端影响非常大。有相当多的前端开始转型为 iOS 工程师（转型为 Android 的比较少，有部分 Java 工程师转型成了 Android 开发），没有转型的，也开始大量投入到 Mobile Web 开发。这个大背景下，前端与客户端技术开始互相融合，特别是在容器层。从 2015 年开始，物联网 IoT 逐步兴起，前端开始涉足 IoT 设备上的应用研发。端的本质是 devices，台式机、手机、IoT 设备都是一台台 devices，很多会直接被用户使用，有用户使用的 devices，就会有人机交互需求，就会有前端的工作价值。前端是离用户最近的工程师，这个定位一直没变。</p>\n<p>非常有意思的是，在移动端的架构里，这几年也出现了基于 RPC 接口 + 网关 + BFF 的架构体系，在研发效率、网络性能等方面均有优势。随着 IoT 应用的涌现与复杂化，我相信最终也会出现 BFF 架构。BFF 模式不仅仅是一种技术架构，从社会分工角度讲，BFF 更是一种多元价值导向的分层架构，每一层都有不错的空间去施展，不仅能发挥工业社会双手的作用，还能使用上双手上面的脑袋。齿轮不再是被动跟着转，而是开始拥有自驱的转动力。同一时期，业界也出现了一些类似的职业融合。比如 DevOps 倡导开发也懂运维，不少大公司在推行开发也懂测试，测试则转型为更专业的质量工具部门，还有前端也懂设计的 DesignOps 的出现等等。各种全栈概念的涌现，都是在重新探索更合理的分层协作模式。纷纷扰扰，成败如风。</p>\n<p>补充一个说明，当年提出的前后端分离，并不准确，这些年一直努力纠正为前后端分层的理念。专业的分工协同对效能的提升很关键。全栈的含义是指分层演化后，每一层的技术栈要求，是每一层横向技能的全，而不是纵向跨层的通（纵向跨多层都能通的人才非常少，就如当今社会已经非常难诞生博物学家了）。不断探索更好的分层协作是有意思的，这就如人类家庭里夫妻的关系一样，男权、女权都不可取，社会的演化最终会视人为人，每个个体平等、自由，社会会以一种必然的不可阻挡的形态往前演进。</p>\n<p>回到前端发展历史，前面说了这么多，只说了一件事，前后端分层协作的各种模式。协作的边界是数据，后端提供数据服务接口，前端消费数据实现人机交互。不同模式下，BaaS（Backend as a Service）的含义各有不同。在 BFF 模式下，由于 BFF 层的运维部署需要，前端还需负责 BFF 层的 PaaS 平台建设。不同模式下的工程体系各有不同，工程的本质是让一群人做好一堆事，涉及代码规范、协作流程、运维部署、性能与安全等很多领域，这里不再一一展开。</p>\n<p>服务端 Node 与各种终端的涌现，让前端进入了大前端范畴，这时候的前端，已远远不只是浏览器端的页面实现技术，而是后端服务与人机界面的连接器。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fgj5HsTiql9rambFQbhDg8t49tw3\" alt=\"v2-374230208f31483237155e80d46f1c0d_hd.jpg\"></p>\n<h2>什么是体验科技</h2>\n<p>我属于无线 ALL IN 战略中，选择留下来继续做 PC Web 的前端。虽然公司重点转向无线，但 PC 业务一直没停。随着近几年整个阿里集团“大中台、小前台”的策略，越来越多的企业级中后台产品处于兵荒马乱阶段，设计师非常缺失，随手一抓，都是大量体验比较糟心的产品。这过程中，越来越感觉什么地方有问题，一定在某些点上我们没做好。当时没多想，就想着既然缺设计师，我们就尝试去招聘。于是体验技术部开始拥有了设计师，非常艰辛的起步，非常感激的是，虽然艰辛，但找到了一些与我一样坚信中后台产品价值的设计师。一旦有了设计师，整个中后台产品的用户体验，一下子就提升上来了。</p>\n<p><img src=\"//dn-cnode.qbox.me/FvNAdF0m7cCZlevYQDFThuRYxvbz\" alt=\"v2-54abf60cd133916e016343ae4adaf376_hd.jpg\"></p>\n<p>设计团队的融入，日常的各种碰撞交流，让我的思维发生了很大变化。前端技术再牛，都很难直接解决产品层的用户体验。对中后台产品来说，设计的价值也远远不止于让产品的颜值提升，设计的更多更多价值，在于深入到产品的业务逻辑里去，去帮助业务梳理产品信息架构与任务流程。用户体验是一个非常综合的事，需要各种专业人士在同一个产品上聚焦发力，一起共同努力才能真正提升产品体验。设计师在这个过程中很痛苦，很多中后台产品都是非常垂直领域的业务产品，中间件、ECS、ODPS 等一堆堆专业术语让设计师们痛苦不堪，幸运的是，我们扛了过来。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fk5n__QHurYmZawYh6-UXJ5Ox0Tv\" alt=\"v2-9b693a1affab86f96e24e0bee03b3e90_hd.jpg\"></p>\n<p>接下来的故事，在今天各个讲师的分享里，不少都有提及。整个团队的重心，开始非常清晰地往几个方向发展：</p>\n<ul>\n<li>TWA 方向：这是比 BFF 更大的概念，上午不四的分享里有详细阐述，可参考 知乎专栏文章 。TWA 是 Techless Web App 的缩写，是一种技术理念，希望越来越多的开发者，可以不用再关注流程、构建、环境、部署等各种事，希望能做到技术无感化（Techless），让每一位开发着能安安静静的快乐编码。</li>\n<li>UI 智能化方向：Ant Design 是一个设计体系，antd 是 Ant Design 的 React 实现。这几年 antd 的发展，不仅让前端编码更快更爽了，同时让一个历史悠久但生生不息的领域重燃希望：是否存在人机交互界面智能可视化搭建的可能？这个领域，这一两年在阿里内部非常火，各种搭建产品层出不穷，目前都还处于比较垂直的领域，泛化到行业级通用的产品还没怎么出现。我们也开始尝试，而且我们相信天时地利人和，一定能折腾出点什么，正在努力中，或许在下次 SEE Conf 大会中会展示给大家。</li>\n<li>数据可视化方向：下午绝云和御术的分享，相信大家对 G2 和 AntV 已经有了一个整体了解。可视化方向我们是从 2014 年开始正式投入人员去做，最开始的想法来自科幻片，大家如果喜欢看科幻片的话，会留意到各种人机交互界面都是各种可视化效果了，很少很少有传统网页。可视化是个历史非常悠久的领域，我们小学时学会的乘法竖式，就是一种可视化，可以帮助我们减少记忆成本，同时提升计算速度。</li>\n<li>图形互动化方向： 上午好修和景夫有分享，这一块才开始一年多，是我们非常笃定的一个方向。很多小孩，对书本都比较抗拒，但对游戏有着天生的喜爱。蚂蚁森林让大家从表单形式的公益，变成了互动游戏型的公益。越来越多的人机交互形式，会是有互动交互的图形界面。应用的泛互动化，是一个很大趋势。支付宝是个生活服务平台，各种生活服务的互动有趣化，一定是更有吸引力的。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fui53ymFhJc0JS0IA0ZXqUvBNFiQ\" alt=\"v2-6830ebf2ca603dca8bd33723d73220e3_hd.jpg\"></p>\n<p>看更远的未来，我相信对体验科技来说，自然化和虚拟化会是两个大趋势。</p>\n<p>我现在在分享这个 PPT，要翻页时，需要点击键盘按钮，为什么电脑不能直接理解我的意图而自动翻页呢？比如我只要头往下示意一下，就能自然而然翻到下一页。我们现在很多行为，跳脱出来看，能发现很多很多不自然。天猫精灵等各种智能音箱，真正去用时，离自然交互还有比较远的距离。Ant Design 设计价值观里，最最重要的就是自然价值观，一切才刚刚开始探索。</p>\n<p>再说虚拟化。虚拟化不仅仅指 AR、VR 等技术，看过黑客帝国、西部世界等科幻片的，会对虚拟化有更多体感。如果以后每个小孩出生时，就会被植入一个能五感俱全的芯片，这种情况下，我们的人机交互会是怎么样的。太多可能性与挑战在等着我们。</p>\n<p>这一切都是体验科技，是技术与设计的融合，是服务与用户连接，是下图中的一个公式。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fh5rgc3RVIRYuQYZSXMdKlBKlfnB\" alt=\"v2-773def061a6dd38cd97c52f040da29cc_hd.jpg\"></p>\n<p><img src=\"//dn-cnode.qbox.me/FpueJ6H7sBiB7kVsLORMYQpjDClK\" alt=\"v2-e4186cd37a1f978abbf64970dee50ba9_hd.jpg\"></p>\n<p>体验科技是 UX = f(services) 这个公式，能将各种各种的 services（后端服务） 通过技术与设计的融合，转变成体验一流的用户产品。这个公式的一个实现，就是蚂蚁体验云。蚂蚁体验云的初心，是希望能帮助有梦想的你，将一个个优秀的想法，通过体验云实现成一个个终端产品。\n<img src=\"//dn-cnode.qbox.me/FjtnnNqNeyh5rH4MTreunWUgsNgj\" alt=\"v2-ab3eae986630f436d1c6b751f4a8d895_hd.jpg\"></p>\n<p>体验云才刚刚起步，目前已在内部服务蚂蚁金服、阿里巴巴集团，同时快速孵化出了云凤蝶、语雀、小钱袋等创新产品。虽然还很不完善，但我们希望能尽快与用户一起成长。很多激动人心的事正在发生，通过体验科技的开放，我们希望着能为世界带来更多平等的机会。\n<img src=\"//dn-cnode.qbox.me/FgGx0MFi9k0eJAeLX3icMz6YLD9v\" alt=\"v2-98323a7d1c563df55151451066a7709e_hd.jpg\"></p>\n<p>感谢聆听，期待交流。</p>\n<p>附 SEE Conf 演讲视频： <a href=\"http://v.youku.com/v_show/id_XMzMwMzg2MDIwOA==.html\">优酷地址 </a></p>\n<p>最后，演讲 PPT 已精心整理并转换为 PDF 上传至<a href=\"http://yuque.com/seeconf\"> SEE Conf 语雀在线知识库</a>，欢迎下载（请 注册语雀，个人描述内注明 #知乎seeconf# 便可快速申请邀请码，登录后即可下载）</p>\n</div>","title":"玉伯《从前端技术到体验科技（附演讲视频）》","last_reply_at":"2018-01-17T14:30:58.022Z","good":false,"top":true,"reply_count":14,"visit_count":3973,"create_at":"2018-01-09T11:33:56.183Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"592917b59e32cc84569a7458","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><p>本来提供开发api，目的是为了开发第三方应用或客户端，如果大家用来学习也是好的，但现在很多人太过分了，随意发帖，at，严重影响了社区的用户，故而决定开始严查</p>\n<p>以下情况，直接封号</p>\n<ul>\n<li>测试标题</li>\n<li>无任何内容</li>\n<li>无意义回复</li>\n<li>测试帖，5分钟内没有删除</li>\n</ul>\n<p>欢迎大家监督</p>\n<p>封号</p>\n<ul>\n<li><a href=\"https://cnodejs.org/user/Mwangzhi\">https://cnodejs.org/user/Mwangzhi</a></li>\n<li><a href=\"https://cnodejs.org/user/lw6395\">https://cnodejs.org/user/lw6395</a></li>\n<li><a href=\"https://cnodejs.org/user/shengliang74\">https://cnodejs.org/user/shengliang74</a>  竟然挑衅，发帖说你来打我呀。。。。</li>\n<li><a href=\"https://cnodejs.org/user/h5-17\">https://cnodejs.org/user/h5-17</a> <a href=\"/user/h5-17\">@h5-17</a></li>\n<li><a href=\"https://cnodejs.org/user/592php\">https://cnodejs.org/user/592php</a> <a href=\"/user/592php\">@592php</a></li>\n</ul>\n<hr>\n<p>20170601更新</p>\n<p><a href=\"https://cnodejs.org/?tab=dev\">https://cnodejs.org/?tab=dev</a>  目前开了一个『客户端测试』专区，以后开发新客户端的同学，帖子直接发到这个专区去。tab 的值是 dev。</p>\n<p><img src=\"//dn-cnode.qbox.me/FundjyBuYk60yqQ-PdKstrPKY-7-\" alt=\"image.png\"></p>\n</div>","title":"测试请发到客户端测试专区，违规影响用户的，直接封号","last_reply_at":"2018-01-03T15:43:22.119Z","good":false,"top":true,"reply_count":147,"visit_count":36305,"create_at":"2017-05-27T06:07:49.278Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"5a653da29d371d4a059eecbd","author_id":"5a3075929807389a1809f330","tab":"ask","content":"<div class=\"markdown-text\"><p>点餐类的，单商户的，业务暂时不复杂\nnode不能做商城么？为什么有人这么说</p>\n</div>","title":"商城用哪些框架比较适合呢？点餐类的","last_reply_at":"2018-01-22T02:36:59.952Z","good":false,"top":false,"reply_count":2,"visit_count":64,"create_at":"2018-01-22T01:25:54.544Z","author":{"loginname":"varwx","avatar_url":"https://avatars3.githubusercontent.com/u/32264346?v=4&s=120"}},{"id":"595d9ad5a4de5625080fe118","author_id":"595d976b10d696af07768a24","tab":"share","content":"<div class=\"markdown-text\"><h1>Mongoose快速入门</h1>\n<h1>1.基础介绍</h1>\n<h2>1.1安装 引用</h2>\n<p>启动数据库命令</p>\n<pre class=\"prettyprint\"><code>\tmongod --dbpath=D:\\Data\\mongodb\\_data\n</code></pre><p>–dbpath：指定数据存储位置</p>\n<p>连接本地的test数据库</p>\n<pre class=\"prettyprint\"><code>\tvar mongoose = require(&#x27;mongoose&#x27;);\n\n\tvar db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);\n\n\tdb.connection.on(&quot;error&quot;, function (error) {\n\n    \tconsole.log(&quot;数据库连接失败：&quot; + error);\n\n\t});\n\n\tdb.connection.on(&quot;open&quot;, function () {\n\n   \t\tconsole.log(&quot;------数据库连接成功！------&quot;);\n\n\t});\n</code></pre><h2>1.2 Schema简介</h2>\n<p>Schema：一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是&quot;集合&quot;的模型骨架。</p>\n<p>那如何去定义一个Schema呢，请看示例：</p>\n<pre class=\"prettyprint\"><code>\tvar mongoose = require(&quot;mongoose&quot;);\n\n\tvar TestSchema = new mongoose.Schema({\n\n    \tname : { type:String },&#x2F;&#x2F;属性name,类型为String\n\n    \tage  : { type:Number, default:0 },&#x2F;&#x2F;属性age,类型为Number,默认为0\n\n    \ttime : { type:Date, default:Date.now },\n\n    \temail: { type:String,default:&#x27;&#x27;}\n\n\t});\n</code></pre><blockquote>\n<p>注：Schema定义集合结构（定义表的列）</p>\n</blockquote>\n<h2>1.3 Model–操作数据库</h2>\n<pre class=\"prettyprint\"><code>\n\tvar db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);\n\n\t&#x2F;&#x2F; 创建Model\n\n\tvar TestModel = db.model(&quot;test1&quot;, TestSchema);\n\n## 1.4 Entity--给集合赋值\n\n\tvar TestEntity = new TestModel({\n\n      \t name : &quot;Lenka&quot;,\n\n       \tage  : 36,\n\n       \temail: &quot;lenka@qq.com&quot;\n\n\t});\n\n\tconsole.log(TestEntity.name); &#x2F;&#x2F; Lenka\n\n\tconsole.log(TestEntity.age); &#x2F;&#x2F; 36\n</code></pre><h2>1.5 创建集合</h2>\n<pre class=\"prettyprint\"><code>\t&#x2F;&#x2F;引入数据库模块\n\n\tvar mongoose = require(&quot;mongoose&quot;);\n\n\t&#x2F;&#x2F;连接本地名为test的数据库，格式\n\n\t&#x2F;&#x2F;var db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;user:pass@localhost:port&#x2F;database&quot;);\n\n\tvar db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);\n\n\t&#x2F;&#x2F;用Schema定义集合结构\n\n\tvar TestSchema = new mongoose.Schema({\n\n    \tname : { type:String },\n\n    \tage  : { type:Number, default:0 },\n\n    \temail: { type:String },\n\n    \ttime : { type:Date, default:Date.now }\n\n\t});\n\n\t&#x2F;&#x2F;创建model,在内存中创建结构为TestSchema名为test1的集合\n\n\tvar TestModel = db.model(&quot;test1&quot;, TestSchema );\n\n\t&#x2F;&#x2F;插入数据到内存中的test1集合\n\n\tvar TestEntity = new TestModel({\n\n    \tname : &quot;helloworld&quot;,\n\n    \tage  : 28,\n\n    \temail: &quot;helloworld@qq.com&quot;\t\n\n\t});\n\n\t&#x2F;&#x2F;将test1写入到数据库中\n\n\tTestEntity.save(function(error,doc){\n\n  \tif(error){\n\n     \tconsole.log(&quot;error :&quot; + error);\n\n  \t}else{\n\n     \tconsole.log(doc);\n\n  \t}\n\n\t});\n</code></pre><h2>1.6 小结</h2>\n<p>本章节学习了如何通过Mongoose去创建一个数据库&quot;集合&quot;，还有定义&quot;集合&quot;的基本组成结构并使其具有相应的操作数据库能力。</p>\n<p>简单回顾：</p>\n<ol>\n<li>\n<p>Schema：数据库集合的模型骨架，或者是数据属性模型传统意义的表结构。</p>\n</li>\n<li>\n<p>Model ：通过Schema构造而成，除了具有Schema定义的数据库骨架以外，还可以具体的操作数据库。</p>\n</li>\n<li>\n<p>Entity：通过Model创建的实体，它也可以操作数据库。</p>\n</li>\n</ol>\n<h1>2 增删改查</h1>\n<h2>2.1查询</h2>\n<pre class=\"prettyprint\"><code>find查询： obj.find(查询条件,callback);\n\n\tModel.find({},function(error,docs){\n\n   \t&#x2F;&#x2F;若没有向find传递参数，默认的是显示所有文档\n\n\t});\n\n\tModel.find({ &quot;age&quot;: 28 }, function (error, docs) {\n\n \t if(error){\n\n    \tconsole.log(&quot;error :&quot; + error);\n\n \t }else{\n\n    \tconsole.log(docs); &#x2F;&#x2F;docs: age为28的所有文档\n\n\t}\n\n\t});\n</code></pre><h2>2.2model保存方法</h2>\n<pre class=\"prettyprint\"><code>Model.create(文档数据, callback))\n\n\tModel.create({ name:&quot;model\\_create&quot;, age:26}, function(error,doc){\n\n    \tif(error) {\n\n        \tconsole.log(error);\n\n    \t} else {\n\n        \tconsole.log(doc);\n\n    \t}\n\n\t});\n</code></pre><h2>2.3 entity保存方法</h2>\n<pre class=\"prettyprint\"><code>Entity.save(文档数据, callback))\n\n\tvar Entity = new Model({name:&quot;entity\\_save&quot;,age: 27});\n\n\tEntity.save(function(error,doc) {\n\n\t  if(error) {\n\n        \tconsole.log(error);\n\n    \t} else {\n\n        \tconsole.log(doc);\n\n    \t}\n\n\t});\n\nmodel调用的是create方法，entity调用的是save方法\n</code></pre><h2>2.4 数据更新</h2>\n<pre class=\"prettyprint\"><code>obj.update(查询条件,更新对象,callback);\n\n\tvar conditions = {name : &#x27;test\\_update&#x27;};\n\n\tvar update = {$set : { age : 16 }};\n\n\tTestModel.update(conditions, update, function(error){\n\n    \tif(error) {\n\n        \tconsole.log(error);\n\n    \t} else {\n\n        \tconsole.log(&#x27;Update success!&#x27;);\n\n    \t}\n\n\t});\n</code></pre><h2>2.5 删除数据</h2>\n<pre class=\"prettyprint\"><code>obj.remove(查询条件,callback);\n\n\tvar conditions = { name: &#x27;tom&#x27; };\n\n\tTestModel.remove(conditions, function(error){\n\n   \t if(error) {\n\n       \t console.log(error);\n\n    \t} else {\n\n        \tconsole.log(&#x27;Delete success!&#x27;);\n\n    \t}\n\n\t});\n</code></pre><h2>2.6 小结</h2>\n<ol>\n<li>\n<p>查询：find查询返回符合条件一个、多个或者空数组文档结果。</p>\n</li>\n<li>\n<p>保存：model调用create方法，entity调用的save方法。</p>\n</li>\n<li>\n<p>更新：obj.update(查询条件,更新对象,callback)，根据条件更新相关数据。</p>\n</li>\n<li>\n<p>删除：obj.remove(查询条件,callback)，根据条件删除相关数据。</p>\n</li>\n</ol>\n<h1>3 简单查询</h1>\n<h2>3.1 find过滤查询</h2>\n<p>属性过滤 find(Conditions,field,callback);</p>\n<p>field省略或为Null，则返回所有属性。</p>\n<pre class=\"prettyprint\"><code>\t&#x2F;&#x2F;返回只包含一个键值name、age的所有记录\n\n\tModel.find({},{name:1, age:1, \\_id:0}，function(err,docs){\n\n   \t&#x2F;&#x2F;docs 查询结果集\n\n\t})\n</code></pre><blockquote>\n<p>说明：我们只需要把显示的属性设置为大于零的数就可以，当然1是最好理解的，_id是默认返回，如果不要显示加上(&quot;_id&quot;:0)，但是，对其他不需要显示的属性且不是_id，如果设置为0的话将会抛异常或查询无果</p>\n</blockquote>\n<h2>3.2 小结</h2>\n<ol>\n<li>\n<p>find过滤查询 ：find查询时我们可以过滤返回结果所显示的属性个数。</p>\n</li>\n<li>\n<p>findOne查询 ：只返回符合条件的首条文档数据。</p>\n</li>\n<li>\n<p>findById查询：根据文档_id来查询文档。</p>\n</li>\n</ol>\n<h1>4.高级查询</h1>\n<h2>4.1 大于、小于</h2>\n<p>$gt(&gt;)、$lt(&lt;)、$lte(&lt;=)、$gte(&gt;=)</p>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        Model.find({&quot;age&quot;:{&quot;$gt&quot;:18}},function(error,docs){\n\n          &#x2F;&#x2F;查询所有nage大于18的数据\n\n        });\n</code></pre><h2>4.2不等于</h2>\n<p>$ne(!=)</p>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        Model.find({ age:{ $ne:24}},function(error,docs){\n\n                &#x2F;&#x2F;查询age不等于24的所有数据\n\n        });\n</code></pre><p><strong>$ne可以匹配单个值，也可以匹配不同类型的值。</strong></p>\n<h2>4.3 匹配</h2>\n<p>$in 包含、等于</p>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        Model.find({ age:{ $in: 20}},function(error,docs){\n\n          &#x2F;&#x2F;查询age等于20的所有数据\n\n        });\n\n        Model.find({ age:{$in:[20,30]}},function(error,docs){\n\n         &#x2F;&#x2F;可以把多个值组织成一个数组\n\n        });\n</code></pre><h2>4.4 或者</h2>\n<p>$or</p>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        Model.find({&quot;$or&quot;:[{&quot;name&quot;:&quot;yaya&quot;},{&quot;age&quot;:28}]},function(error,docs){\n\n         &#x2F;&#x2F;查询name为yaya或age为28的全部文档\n\n        });\n</code></pre><h2>4.5 存在</h2>\n<p>$exists</p>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        Model.find({name: {$exists: true}},function(error,docs){\n\n         &#x2F;&#x2F;查询所有存在name属性的文档\n\n        });\n\n        Model.find({telephone: {$exists: false}},function(error,docs){\n\n         &#x2F;&#x2F;查询所有不存在telephone属性的文档\n\n        });\n</code></pre><h2>4.6 小结</h2>\n<ol>\n<li>\n<p>$gt(&gt;),$lt(&lt;),$lte(&lt;=),$gte(&gt;=)操作符：针对Number类型的查询具体超强的排除性。</p>\n</li>\n<li>\n<p>$ne(!=)操作符：相当于不等于、不包含，查询时可根据单个或多个属性进行结果排除。</p>\n</li>\n<li>\n<p>$in操作符：和$ne操作符用法相同，但意义相反。</p>\n</li>\n<li>\n<p>$or操作符：可查询多个条件，只要满足其中一个就可返回结果值。</p>\n</li>\n<li>\n<p>$exists操作符：主要用于判断某些属性是否存在。</p>\n</li>\n</ol>\n<h1>5.游标</h1>\n<h2>5.1 简介</h2>\n<p>数据库使用游标返回find的执行结果。客户端对游标的实现通常能够对最终结果进行有效的控制。可以限制结果的数量，略过部分结果，根据任意键按任意顺序的组合对结果进行各种排序，或者是执行其他一些强的操作。</p>\n<h2>5.2 limit函数的基本用法</h2>\n<p>限制数量：find(Conditions,fields,options,callback);</p>\n<pre class=\"prettyprint\"><code>        Model.find({},null,{limit:20},function(err,docs){\n\n                console.log(docs);\n\n        });\n</code></pre><h2>5.3 skip函数的基本用法</h2>\n<p>skip函数和limit类似，都是对返回结果数量进行操作，不同的是skip函数的功能是略过指定数量的匹配结果，返回余下的查询结果。</p>\n<p>示例：</p>\n<p>1.跳过数量：find(Conditions,fields,options,callback);</p>\n<pre class=\"prettyprint\"><code>Model.find({},null,{skip:4},function(err,docs){\n\n    console.log(docs);\n\n});\n</code></pre><p><strong>如果查询结果数量中少于4个的话，则不会返回任何结果。</strong></p>\n<h2>5.4 sort函数的基本用法</h2>\n<p>sort函数可以将查询结果数据进行排序操作，该函数的参数是一个或多个键/值对，键代表要排序的键名，值代表排序的方向，1是升序，-1是降序。</p>\n<p>1.结果排序：find(Conditions,fields,options,callback);</p>\n<pre class=\"prettyprint\"><code>        Model.find({},null,{sort:{age:-1}},function(err,docs){\n\n         &#x2F;&#x2F;查询所有数据，并按照age降序顺序返回数据docs\n\n        });\n</code></pre><h2>5.6 小结</h2>\n<ol>\n<li>\n<p>limit函数：限制返回结果的数量。</p>\n</li>\n<li>\n<p>skip函数：略过指定的返回结果数量。</p>\n</li>\n<li>\n<p>sort函数：对返回结果进行有效排序。</p>\n</li>\n</ol>\n<h1>6 属性方法</h1>\n<h2>6.1 实例方法</h2>\n<p>有的时候，我们创造的Schema不仅要为后面的Model和Entity提供公共的属性，还要提供公共的方法.那怎么在Schema下创建一个实例方法呢，请看示例：</p>\n<pre class=\"prettyprint\"><code>        var mongoose = require(&#x27;mongoose&#x27;);\n\n        var saySchema = new mongoose.Schema({name : String});\n\n        saySchema.method(&#x27;say&#x27;, function () {\n\n         console.log(&#x27;Trouble Is A Friend&#x27;);\n\n        })\n\n        var say = mongoose.model(&#x27;say&#x27;, saySchema);\n\n        var lenka = new say();\n\n        lenka.say(); &#x2F;&#x2F;Trouble Is A Friend\n</code></pre><h2>6.2 Schema静态方法</h2>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        var mongoose = require(&quot;mongoose&quot;);\n\n        var db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);\n\n        var TestSchema = new mongoose.Schema({\n\n                name : { type:String },\n\n                age  : { type:Number, default:0 },\n\n                email: { type:String, default:&quot;&quot; },\n\n                time : { type:Date, default:Date.now }\n\n        });\n\n        TestSchema.static(&#x27;findByName&#x27;, function (name, callback) {\n\n                return this.find({ name: name }, callback);\n\n        });\n\n        var TestModel = db.model(&quot;test1&quot;, TestSchema );\n\n        TestModel.findByName(&#x27;tom&#x27;, function (err, docs) {\n\n        &#x2F;&#x2F;docs所有名字叫tom的文档结果集\n\n        });\n</code></pre><h2>6.3 Schema追加方法</h2>\n<p>为Schema模型追加speak方法</p>\n<p>示例：</p>\n<pre class=\"prettyprint\"><code>        var mongoose = require(&quot;mongoose&quot;);\n\n        var db = mongoose.connect(&quot;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test&quot;);\n\n        var TestSchema = new mongoose.Schema({\n\n                name : { type:String },\n\n                age  : { type:Number, default:0 },\n\n                email: { type:String, default:&quot;&quot; },\n\n                time : { type:Date, default:Date.now }\n\n        });\n\n        TestSchema.methods.speak = function(){\n\n         console.log(&#x27;我的名字叫&#x27;+this.name);\n\n        }\n\n        var TestModel = db.model(&#x27;test1&#x27;,TestSchema);\n\n        var TestEntity = new TestModel({name:&#x27;Lenka&#x27;});\n\n        TestEntity.speak();&#x2F;&#x2F;我的名字叫Lenka\n</code></pre><blockquote>\n<p>强力推荐：<a href=\"http://www.hubwiz.com/\">汇智网</a></p>\n</blockquote>\n</div>","title":"Mongoose快速入门","last_reply_at":"2018-01-22T02:18:11.681Z","good":false,"top":false,"reply_count":6,"visit_count":912,"create_at":"2017-07-06T02:05:09.647Z","author":{"loginname":"18820227745","avatar_url":"https://avatars0.githubusercontent.com/u/25097125?v=4&s=120"}},{"id":"5a65496dafa0a121784a8e34","author_id":"5a6546a5afa0a121784a8e33","tab":"ask","content":"<div class=\"markdown-text\"><p>第一次访问没有问题，第二次访问会卡在执行SQL的地方。<img src=\"//dn-cnode.qbox.me/FuUctYod8Y4UeugvgVvFgN0xYiDH\" alt=\"错误2.png\">\n代码如下：\n\ttedious.js\n\tconst Connection = require(‘tedious’).Connection;<br>\nconst Request = require(‘tedious’).Request;</p>\n<p>exports.mssql = function(config){<br>\nthis.connection = new Connection(config);</p>\n<pre class=\"prettyprint\"><code>this.query = function(str,callback){          &#x2F;&#x2F;执行查询    \n    var connection = this.connection;    \n    var rows={};    \n    connection.on(&#x27;connect&#x27;, function(err){                 &#x2F;&#x2F;连接数据库，执行匿名函数    \n        if(err){    \n            callback({&#x27;err&#x27;:err[&#x27;message&#x27;]+&#x27;请检查账号、密码是否正确,且数据库存在&#x27;});    \n        }else{    \n            var request = new Request(str,function(err, rowCount){      \n                if(err)err = {&#x27;err&#x27;:err[&#x27;message&#x27;]};    \n                callback(err,rows);    \n              &#x2F;&#x2F;  connection.close();    \n            });    \n                \n            var n=0;                        \n            request.on(&#x27;row&#x27;, function(columns) {                            &#x2F;&#x2F;查询成功数据返回    \n                rows[n]={};    \n                columns.forEach(function(column) {    \n                        rows[n][column.metadata.colName] = column.value;        &#x2F;&#x2F;获取数据              \n                });    \n                n++;    \n            });    \n            \n            connection.execSql(request);                                 &#x2F;&#x2F;执行sql语句    \n        }    \n    });    \n}    \n</code></pre><p>}</p>\n<p>client2.js：</p>\n<p>const request = require(‘request-json’);\nvar client = request.createClient(‘<a href=\"http://192.168.1.83:8081/\">http://192.168.1.83:8081/</a>’);</p>\n<p>var mssql = require(’./tedious.js’);\nvar conn = new mssql.mssql({ ‘userName’: ‘sa’, ‘password’: ‘123’, ‘server’: ‘localhost’, ‘options’: { ‘port’: 1433, ‘database’: ‘WEIGHT20’ } });</p>\n<p>var lastId = 0;\nvar timeBw = 1 * 1000;</p>\n<p>class postData {\n_getDate(fc) {</p>\n<pre class=\"prettyprint\"><code>    console.log(&#x27;取称重数据 ID&#x27;, lastId);\n    var sql = &#x27;SELECT top 1  * FROM \\u79f0\\u91cd\\u4fe1\\u606f  where \\u5e8f\\u53f7&gt;&#x27; + lastId + &#x27; order by \\u5e8f\\u53f7 &#x27;;\n    console.log(&#x27;SQL&#x27;, sql);\n    conn.query(sql, function (err, data) {\n        if (!err) {\n            &#x2F;&#x2F;console.log(data)       &#x2F;&#x2F;成功返回数据    \n            fc(data);\n        }\n        else {\n            fc([]);\n            console.log(err)      &#x2F;&#x2F;出错返回    \n        }\n    }\n    );\n}\n_postDate(item, fc) {\n    lastId = item[&#x27;\\u5e8f\\u53f7&#x27;];\n    var postData = {};\n    postData[&#x27;creator_id&#x27;] = item[&#x27;\\u5e8f\\u53f7&#x27;];\n    postData[&#x27;weight_id&#x27;] = &#x27;code002&#x27;;\n    postData[&#x27;weight_code&#x27;] = &#x27;code002&#x27;;\n    postData[&#x27;weight_rfid&#x27;] = &#x27;0&#x27;;\n    postData[&#x27;veh_id&#x27;] = item[&#x27;\\u6d41\\u6c34\\u53f7&#x27;];\n    postData[&#x27;car_no&#x27;] = item[&#x27;\\u8f66\\u53f7&#x27;];\n    postData[&#x27;weight_gross&#x27;] = item[&#x27;\\u6bdb\\u91cd&#x27;];\n    postData[&#x27;weight_veh&#x27;] = item[&#x27;\\u76ae\\u91cd&#x27;];\n    postData[&#x27;weight_net&#x27;] = item[&#x27;\\u51c0\\u91cd&#x27;];\n    postData[&#x27;garbage_type&#x27;] = item[&#x27;\\u8d27\\u540d&#x27;];\n    postData[&#x27;weight_date&#x27;] = item[&#x27;\\u76ae\\u91cd\\u65f6\\u95f4&#x27;];\n    postData[&#x27;delivery_unit&#x27;] = item[&#x27;\\u53d1\\u8d27\\u5355\\u4f4d&#x27;];\n    postData[&#x27;prj_id&#x27;] = 2;\n    postData[&#x27;tcar_company_id&#x27;] = 0;\n    postData[&#x27;creator_id&#x27;] = item[&#x27;\\u5e8f\\u53f7&#x27;];\n    console.log(&#x27;post data&#x27;, postData);\n    client.post(&#x27;&#x2F;jsonapi&#x2F;cancu_weight&#x2F;add.json&#x27;,\n        postData, function (err, res, body) {\n            if (err) {\n                console.error(err);\n            }\n            else {\n                console.log(&#x27;post resp&#x27;, body);\n                fc({ code: 0 });\n            }\n        });\n}\n\n_time(fc) {\n    var _self = this;\n    _self._getDate((d) =&gt; {\n        if (d.length &lt;= 0) {\n            fc({ code: -1 });\n            return;\n        }\n        _self._postDate(d[0], fc);\n    })\n}\n\nrun(fc) {\n    var _self = this;\n    _self._time(d =&gt; {\n        setTimeout(function () {\n            _self.run();\n        }, timeBw);\n    }, timeBw)\n}\n</code></pre><p>}</p>\n<p>var t = new postData();\nt.run();</p>\n<p><strong>请各位大佬指点</strong></p>\n</div>","title":"求助大佬，使用tedious模块连接SQLserver数据库遇到的问题。","last_reply_at":"2018-01-22T02:16:13.072Z","good":false,"top":false,"reply_count":0,"visit_count":21,"create_at":"2018-01-22T02:16:13.072Z","author":{"loginname":"adduan","avatar_url":"https://avatars3.githubusercontent.com/u/35551072?v=4&s=120"}},{"id":"5a637604ce45d440451461c5","author_id":"5a5c03aca3692d014f4f1472","tab":"ask","content":"<div class=\"markdown-text\"><p>比如,在一个file.js里面, 引入fs模块\n然后, 其中的一个函数中有一条语句是  fs.readdir(“某一个路径”,(err, files)=&gt;{</p>\n<p>});</p>\n<p>然后其他的文件调用这个文件,比如入口文件调用这个文件file.js\n在index.js中写到</p>\n<p>var file = require(&quot;./models/file.js&quot;);\n调用:\nfile.上面友fs.readdir语句的函数,\n那么, Nodejs自带的模块,路径是相对于运行时,还是引入的时候?</p>\n</div>","title":"Nodejs自带的模块,路径是相对于运行时,还是引入的时候?","last_reply_at":"2018-01-22T02:01:31.256Z","good":false,"top":false,"reply_count":3,"visit_count":152,"create_at":"2018-01-20T17:01:56.637Z","author":{"loginname":"AmandaYi","avatar_url":"https://avatars1.githubusercontent.com/u/23202919?v=4&s=120"}},{"id":"5a6335bbafa0a121784a8dfe","author_id":"592ee9eaba8670562a40f6a4","tab":"ask","content":"<div class=\"markdown-text\"><p>使用ng build --prod 打包时，报错：</p>\n<p><img src=\"//dn-cnode.qbox.me/Fm55A-SLhNqpbq9_Kr1K2t7xb7eu\" alt=\"1.PNG\"></p>\n<p><img src=\"//dn-cnode.qbox.me/FmzDyxE2hOtj3rNnBN8h_O4EnuNy\" alt=\"2.PNG\"></p>\n<p>下面是开发环境：</p>\n<p><img src=\"//dn-cnode.qbox.me/Fgs-5ZN_coGiiEUOuTd4XnHfiY8V\" alt=\"ng-version.PNG\"></p>\n<p>求教大佬们，怎么解决啊？</p>\n<p>有升级过angular-cli，还是同样状况。</p>\n</div>","title":"angular4 打包问题","last_reply_at":"2018-01-22T02:00:52.580Z","good":false,"top":false,"reply_count":2,"visit_count":141,"create_at":"2018-01-20T12:27:39.849Z","author":{"loginname":"hesen1","avatar_url":"https://avatars0.githubusercontent.com/u/20394832?v=4&s=120"}},{"id":"5a653e5aafa0a121784a8e2e","author_id":"5a3075929807389a1809f330","tab":"ask","content":"<div class=\"markdown-text\"><p>如题</p>\n</div>","title":"cnode搜索是google的站内搜索么？没翻墙。怎么搜索问题？","last_reply_at":"2018-01-22T01:41:37.486Z","good":false,"top":false,"reply_count":2,"visit_count":64,"create_at":"2018-01-22T01:28:58.735Z","author":{"loginname":"varwx","avatar_url":"https://avatars3.githubusercontent.com/u/32264346?v=4&s=120"}},{"id":"5a61ad4ece45d44045146172","author_id":"59c464898812ce51127a90e4","tab":"ask","content":"<div class=\"markdown-text\"><p>node Server 开启，server 可能因为各种各样的问题异常退出，虽然我能够通过线程监控手段让Server在短时间内起死回生，但Server死之前的那些用户请求附带繁杂的数据库请求以及文件请求怎么处理？</p>\n</div>","title":"【新手提问】关于node经常挂掉，数据库怎么办","last_reply_at":"2018-01-21T14:40:06.476Z","good":false,"top":false,"reply_count":13,"visit_count":343,"create_at":"2018-01-19T08:33:18.508Z","author":{"loginname":"Monisuy","avatar_url":"https://avatars2.githubusercontent.com/u/25356455?v=4&s=120"}},{"id":"5a649ff09d371d4a059eecb4","author_id":"5a5c0a17a3692d014f4f1477","tab":"share","content":"<div class=\"markdown-text\"><p>技术有点吐，大佬要多多指教。</p>\n<p>用到的技术有 vue全家桶，hadoop</p>\n<p>还在开发中，后期开源—</p>\n<p><img src=\"//dn-cnode.qbox.me/FqRYcmVVSAYEnoptBmavZGOFrvN2\" alt=\"63$6$ZJ%Y7QY6VMVO6P2AW7.png\"></p>\n<p>hadoop web-restfu-api 操作 配置图\n<img src=\"//dn-cnode.qbox.me/FoFz-8tqgi49utaBGEeYqKQp16d4\" alt=\"hadoop-web-restful-api.png\"></p>\n</div>","title":"vue-Hadoop 网盘Demo 实战","last_reply_at":"2018-01-21T14:13:04.408Z","good":false,"top":false,"reply_count":0,"visit_count":119,"create_at":"2018-01-21T14:13:04.408Z","author":{"loginname":"1160007652","avatar_url":"https://avatars3.githubusercontent.com/u/26641790?v=4&s=120"}},{"id":"5a649ed5afa0a121784a8e22","author_id":"584139e9539c22b15689981c","tab":"ask","content":"<div class=\"markdown-text\"><p>我们是做Electron应用的，需要找个在客户端存数据用的库。\n主要看中的点是：API简洁易懂，速度够快，每种操作有Callback方法。</p>\n<p>看了大概四五个库的说明，有levelDb，pouchDB，LokiJS等等，整体感觉nedb不错。\n查了半天，看到有人说，整个数据库最大只能达到256M，这个对我们来说还好。</p>\n<p>请问，这个库还有其他坑需要注意吗？\n多谢各位</p>\n</div>","title":"请问各位用过nedb的大神，这个数据库有什么坑吗？","last_reply_at":"2018-01-21T14:08:21.951Z","good":false,"top":false,"reply_count":0,"visit_count":87,"create_at":"2018-01-21T14:08:21.951Z","author":{"loginname":"hz0324","avatar_url":"https://avatars0.githubusercontent.com/u/5040078?v=4&s=120"}},{"id":"5746cdcf991011691ef17b88","author_id":"57329f1c2e11c7a80c33f87a","tab":"share","content":"<div class=\"markdown-text\"><p>express作为nodejs平台下非常流行的web框架，相信大家都对其已经很熟悉了，对于express的使用这里不再多说，如有需要可以移步到<a href>www.expressjs.com</a>自行查看express的官方文档，今天主要是想说下express的路由机制。</p>\n<p>最近抽时间看了下express的源码，看完源码体会最深刻的还是express的路由机制，感觉搞懂了express的路由就算是基本搞懂了express，而express的路由机制都是router模块来实现，所以在这里对express的router模块实现进行一下简单的整理，所有理解都来自自己对源码的理解，如有不对的地方，还请各位多多拍砖。</p>\n<p>好了，废话不多说了，进入正题，首先先了解一下express源码的目录结构，如下图：\n<img src=\"//dn-cnode.qbox.me/FnuptVMv5TZchESOT0JRT0re7KZ0\" alt=\"express.jpg\">\napplication.js为express的主文件，express.js对application.js进行了包装，对外提供各种API，这里我们不多做说明，我们今天要说的就是router目录下的内容，express关于路由的具体实现都是由这个目录完成。我们先看一个简单的express路由的例子：</p>\n<pre class=\"prettyprint\"><code>var app = express();\napp.get(&#x27;&#x2F;hello&#x27;, function(req,res){\n    res.send(&#x27;hello everyone!!!&#x27;); \n}); \n</code></pre><p>上边就是一个最简单的express路由的例子，将path为 ‘/hello’ 的请求路由到当前的处理函数，并返回 ‘hello everyone!!!’ ，那么我们来一起看看，app.get()何实现的，通过查看代码我们发现源码里并没有app.get()的实现，但仔细找找你会在application.js中发现如下的代码：</p>\n<pre class=\"prettyprint\"><code>methods.forEach(function(method){\n  app[method] = function(path){\n    if (method === &#x27;get&#x27; &amp;&amp; arguments.length === 1) {\n      &#x2F;&#x2F; app.get(setting)\n      return this.set(path);\n    }\n\n    this.lazyrouter();\n\n    var route = this._router.route(path);\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n</code></pre><p>(⊙o⊙)哦，隐藏的好深，原来express对get，post等方法的添加都是动态的，methods来自<a href=\"https://www.npmjs.com/package/methods\">methods</a>这个模块，他提供了和nodejs  http.METHODS 相似的东西，返回了http协议的所有method，这样一个循环搞定了所有method函数的定义，赞一个。</p>\n<p>接下来我们主要分析下函数内部的实现，首先判断如果method等于get，并且参数的长度是1，则直接返回this.set(path)，大家查看express官网的API就可以发现，app.get()函数其实实现了两种功能，如果参数长度是1，则返回app.set()定义的变量，如果参数长度大于1，则进行路由处理。</p>\n<p>继续往下看，<strong>this.lazyrouter()</strong>，从名字来看，好像是懒加载router，那我们看看源码：</p>\n<pre class=\"prettyprint\"><code>app.lazyrouter = function lazyrouter() {\n  if (!this._router) {\n    this._router = new Router({\n      caseSensitive: this.enabled(&#x27;case sensitive routing&#x27;),\n      strict: this.enabled(&#x27;strict routing&#x27;)\n    });\n\n    this._router.use(query(this.get(&#x27;query parser fn&#x27;)));\n    this._router.use(middleware.init(this));\n  }\n};\n</code></pre><p>果然是，如果_router不存在，就new一个Router出来，而这个Router就是我们刚才在目录结构中看到的router目录，也就是今天的主角Router模块。继续上边的代码，加载完_router之后，执行了**this._router.route(path)**这样一行代码，那这行代码有做了什么呢，我们再继续往下挖，我们在router目录下的index.js中找到了它的实现：</p>\n<pre class=\"prettyprint\"><code>proto.route = function route(path) {\n  var route = new Route(path);\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n</code></pre><p>我们可以看到，这里new了一个Route对象，并且new了一个Layer对象，然后将Route对象赋值给layer.route，最后将这个Layer添加到stack数组中。在这里我们先不对Layer进行说明，后边会有专门的介绍，我们先来看看Route，那这个Route又是什么呢，它和Router模块有什么关系呢，我来说下我的理解：</p>\n<blockquote>\n<p>Route模块对应的是route.js，主要是来处理路由信息的，每条路由都会生成一个Route实例。而Router模块对应的是index.js，Router是一个路由的集合，在Router模块下可以定义多个路由，也就是说，一个Router模块会包含多个Route模块。通过上边的代码我们已经知道，每个express创建的实例都会懒加载一个_router来进行路由处理，这个_router就是一个Router模块。</p>\n</blockquote>\n<p>理解了Route和Router的关系，感觉一下子清爽了有木有，O(∩_∩)O哈哈~~~</p>\n<p>好了，我们接着看代码，拿到route对象之后，通过apply的方式调用了route的对应method函数，假如我们现在使用的是get函数，那现在method就等于get。看到这里大家就会发现，express实例在处理路由的时候，会先创建一个Router对象，然后用Router对象和对应的path来生成一个Route对象，最后由Route对象来处理具体的路由实现。</p>\n<p>好了，那接下来我们继续深入研究，看看route.method究竟做了什么，我们找到route.js文件，发现如下的代码：</p>\n<pre class=\"prettyprint\"><code>methods.forEach(function(method){\n  Route.prototype[method] = function(){\n    var handles = flatten(slice.call(arguments));\n\n    for (var i = 0; i &lt; handles.length; i++) {\n      var handle = handles[i];\n\n      if (typeof handle !== &#x27;function&#x27;) {\n        var type = toString.call(handle);\n        var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;\n        throw new Error(msg);\n      }\n\n      debug(&#x27;%s %s&#x27;, method, this.path);\n\n      var layer = Layer(&#x27;&#x2F;&#x27;, {}, handle);\n      layer.method = method;\n\n      this.methods[method] = true;\n      this.stack.push(layer);\n    }\n\n    return this;\n  };\n});\n</code></pre><p>啊啊啊，原来route和application运用了同样的技巧，通过循环methods来动态添加method函数，我们直接看函数内部实现，首先通过入参获取到handles，这里的handles就是我们定义的路由中间件函数，这里我们可以看到是一个数组，所以我们可以给一个路由添加多个中间件函数。接下来循环handles，在每个循环中利用handle来创建一个Layer对象，然后将Layer对象push到stack中去，这个stack其实是Route内部维护的一个数组，用来存放所有的Layer对象。现在你一定想这道这个Layer到底是什么东西，那我们继续往下看，看看layer.js的源代码：</p>\n<pre class=\"prettyprint\"><code>function Layer(path, options, fn) {\n  if (!(this instanceof Layer)) {\n    return new Layer(path, options, fn);\n  }\n\n  debug(&#x27;new %s&#x27;, path);\n  var opts = options || {};\n\n  this.handle = fn;\n  this.name = fn.name || &#x27;&lt;anonymous&gt;&#x27;;\n  this.params = undefined;\n  this.path = undefined;\n  this.regexp = pathRegexp(path, this.keys = [], opts);\n\n  if (path === &#x27;&#x2F;&#x27; &amp;&amp; opts.end === false) {\n    this.regexp.fast_slash = true;\n  }\n}\n</code></pre><p>上边是Layer的构造函数，我们可以看到这里定义handle，params，path和regexp等几个主要的属性：</p>\n<ol>\n<li>其中最重要的就是handle，它就是我们刚刚在route中创建Layer对象传入的中间件函数。</li>\n<li>params其实就是req.params，至于如何实现的我们可以以后再做探讨，今天先不做说明。</li>\n<li>path就是我们定义路由时传入的path。</li>\n<li>regexp对于Layer来说是比较重要的一个属性，因为下边进行路由匹配的时候就是靠它来搞定的，而它的值是由pathRegexp得来的，其实这个pathRegexp对应的是一个第三方模块<a href=\"https://www.npmjs.com/package/path-to-regexp\">path-to-regexp</a>，它的功能是将path转换成regexp，具体用法大家可以自行查看。</li>\n</ol>\n<p>看完属性，我们再来看看Layer有什么方法：</p>\n<pre class=\"prettyprint\"><code>Layer.prototype.match = function match(path) {\n  if (path == null) {\n    &#x2F;&#x2F; no path, nothing matches\n    this.params = undefined;\n    this.path = undefined;\n    return false;\n  }\n\n  if (this.regexp.fast_slash) {\n    &#x2F;&#x2F; fast path non-ending match for &#x2F; (everything matches)\n    this.params = {};\n    this.path = &#x27;&#x27;;\n    return true;\n  }\n\n  var m = this.regexp.exec(path);\n\n  if (!m) {\n    this.params = undefined;\n    this.path = undefined;\n    return false;\n  }\n\n  &#x2F;&#x2F; store values\n  this.params = {};\n  this.path = m[0];\n\n  var keys = this.keys;\n  var params = this.params;\n\n  for (var i = 1; i &lt; m.length; i++) {\n    var key = keys[i - 1];\n    var prop = key.name;\n    var val = decode_param(m[i]);\n\n    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {\n      params[prop] = val;\n    }\n  }\n\n  return true;\n};\n</code></pre><p>match函数主要用来匹配path的，当我们向express发送一个http请求时，当前请求对应的是哪个路由，就是通过这个match函数来判断的，如果path中带有参数，match还会把参数提取出来赋值给params，所以说match是整个路由中很重要的一点。</p>\n<pre class=\"prettyprint\"><code>Layer.prototype.handle_error = function handle_error(error, req, res, next) {\n  var fn = this.handle;\n\n  if (fn.length !== 4) {\n    &#x2F;&#x2F; not a standard error handler\n    return next(error);\n  }\n\n  try {\n    fn(error, req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n</code></pre><p>这个是错误处理函数，专门用来处理错误的。</p>\n<pre class=\"prettyprint\"><code>Layer.prototype.handle_request = function handle(req, res, next) {\n  var fn = this.handle;\n\n  if (fn.length &gt; 3) {\n    &#x2F;&#x2F; not a standard request handler\n    return next();\n  }\n\n  try {\n    fn(req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n</code></pre><p>从上边的代码我们可以看到调用了fn，而这个fn就是layer的handle属性，就是我们定义路由时传入的路由中间件，到这里我们总算找到了我们的路由中间件被执行的地方，是不是很兴奋。好了，到这里我们已经看完了Layer的代码，但Layer到底是做什么的呢，它和Route之间又有什么千丝万缕的联系呢，说说我的理解：</p>\n<blockquote>\n<p>每一个Layer对应一个中间件函数，Layer存储了每个路由的path和handle等信息，并且实现了match和handle的功能。而从前边我们已经知道，每个Route都会维护一个Layer数组，所有可以发现Route和Layer是一对多的关系，每个Route代表一个路由，而每个Layer对应的是路由的每一个中间件函数。</p>\n</blockquote>\n<p>讲完了Route和Layer的关系，我们再来回头看看Router和Layer的关系，我们再来看看index.js中prop.route的代码：</p>\n<pre class=\"prettyprint\"><code>proto.route = function route(path) {\n  var route = new Route(path);\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n</code></pre><p>从代码我们可以看出来Router每次添加一个route，都会把route包装到layer中，并且将layer添加到自己的stack中，那为什么要把route包装到layer中呢，前边我们已经仔细研究了Layer模块的代码，我们发现Layer具有match和handle的功能，这样我们就可以通过Layer的match来进行route的匹配了。这里有一个关键点我们需要特别讲解下，上边的代码中在创建Layer对象的时候传入的handle函数为<strong>route.dispatch.bind(route)</strong>，我们来看看route.js中的route.dispatch：</p>\n<pre class=\"prettyprint\"><code>Route.prototype.dispatch = function dispatch(req, res, done) {\n  var idx = 0;\n  var stack = this.stack;\n  if (stack.length === 0) {\n    return done();\n  }\n\n  var method = req.method.toLowerCase();\n  if (method === &#x27;head&#x27; &amp;&amp; !this.methods[&#x27;head&#x27;]) {\n    method = &#x27;get&#x27;;\n  }\n\n  req.route = this;\n\n  next();\n\n  function next(err) {\n    if (err &amp;&amp; err === &#x27;route&#x27;) {\n      return done();\n    }\n\n    var layer = stack[idx++];\n    if (!layer) {\n      return done(err);\n    }\n\n    if (layer.method &amp;&amp; layer.method !== method) {\n      return next(err);\n    }\n\n    if (err) {\n      layer.handle_error(err, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n};\n</code></pre><p>我们发现dispatch中通过next()获取stack中的每一个layer来执行相应的路由中间件，这样就保证了我们定义在路由上的多个中间件函数被按照定义的顺序依次执行。到这里我们已经知道了单个路由是被如何执行的，那我们定义的多个路由之间又是如何被依次执行的呢，现在我们来看看index.js中的handle函数：</p>\n<pre class=\"prettyprint\"><code>proto.handle = function handle(req, res, out) {\n\n  &#x2F;&#x2F; middleware and routes\n  var stack = self.stack;\n\n  next();\n\n  function next(err) {\n\n    &#x2F;&#x2F; find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true &amp;&amp; idx &lt; stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n      \n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        &#x2F;&#x2F; process non-route handlers normally\n        continue;\n      }\n    }\n\n    &#x2F;&#x2F; no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    &#x2F;&#x2F; this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  }\n};\n</code></pre><p>上边的代码我进行了处理，删除了一些逻辑，只留下关键部分。从上边的代码我们可以看出，这里也是利用next()，来处理stack中的每一个Layer，这里的stack是Router的stack，stack中存贮了多个route对应的layer，获取到每个layer对象之后，用请求的path与layer进行匹配，此处匹配用的是layer.match，如果能匹配到对应的layer，则获得layer.route，如果route不为空则执行对应的<strong>layer.handle_request()</strong>，如果route为空说明这个layer是通过use()添加的非路由中间件，需要特别说明的是，如果通过use()添加的非路由中间件没有指定path，则会在layer.match中默认返回true，也就是说，没有指定path的非路由中间件会匹配所有的http请求。</p>\n<p>到这里，我们基本已经说明了router相关的所有内容，想必看到这里你一定会有点晕，我们接下来来重新梳理一下。看看express究竟是如何对http请求进行路由的。</p>\n<p>当客户端发送一个http请求后，会先进入express实例对象对应的router.handle函数中，router.handle函数会通过next()遍历stack中的每一个layer进行match，如果match返回true，则获取layer.route，执行route.dispatch函数，route.dispatch同样是通过next()遍历stack中的每一个layer，然后执行layer.handle_request，也就是调用中间件函数。直到所有的中间件函数被执行完毕，整个路由处理结束。</p>\n</div>","title":"express源码分析之Router","last_reply_at":"2018-01-21T13:48:10.062Z","good":true,"top":false,"reply_count":12,"visit_count":11001,"create_at":"2016-05-26T10:19:59.631Z","author":{"loginname":"leijianning","avatar_url":"https://avatars.githubusercontent.com/u/14830812?v=3&s=120"}},{"id":"5a5c8d2eafa0a121784a8c05","author_id":"536b0ab9c077d1b33302ad05","tab":"ask","content":"<div class=\"markdown-text\"><p>小弟现在在开发一个内部系统，是基于 Nodejs 的，因为本人后端经验不足，请求大家帮助。</p>\n<p>需求是：现在调用一个接口，这个接口会调用一个 npm 模块，这个模块是一个异步的。</p>\n<p>问题：</p>\n<ol>\n<li>我怎么调用这个 npm 模块</li>\n<li>并且在调用任务完成后知道已经完成</li>\n</ol>\n<p>如果上述问题解决了，怎么如何保证同时调用调用这个服务不冲突呢。</p>\n<p>希望大家不吝赐教。</p>\n</div>","title":"Node 怎么调用服务?","last_reply_at":"2018-01-21T12:41:49.249Z","good":false,"top":false,"reply_count":9,"visit_count":606,"create_at":"2018-01-15T11:14:54.548Z","author":{"loginname":"riskers","avatar_url":"https://avatars3.githubusercontent.com/u/5653652?v=4&s=120"}},{"id":"58ac640e7872ea0864fedf90","author_id":"56c336a38442f7e03c7316ae","tab":"share","content":"<div class=\"markdown-text\"><h1>《koa2进阶学习笔记》附教程demo</h1>\n<blockquote>\n<p>第一次写书，如有错误，欢迎指正！O(∩_∩)O~。\n持续更新笔记，后续会根据koa2 正式发布后添加koa2周边生态使用笔记</p>\n</blockquote>\n<h2>GitHub地址</h2>\n<p><a href=\"https://github.com/ChenShenhai/koa2-note/\">https://github.com/ChenShenhai/koa2-note/</a></p>\n<h2>GitBook地址</h2>\n<p><a href=\"https://chenshenhai.github.io/koa2-note/\">https://chenshenhai.github.io/koa2-note/</a></p>\n<h2>目录</h2>\n<ul>\n<li><a href>1. koa2开始</a>\n<ul>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/start/quick.md\">1.1 快速开始</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/start/async.md\">1.2 async/await使用</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/start/info.md\">1.3 koa2简析结构</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/start/middleware.md\">1.4 koa中间件开发与使用</a></li>\n</ul>\n</li>\n<li><a href>2. 路由</a>\n<ul>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/route/simple.md\">2.1 原生koa2实现路由</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/route/koa-router.md\">2.2 koa-router中间件</a></li>\n</ul>\n</li>\n<li><a href>3. 请求数据获取</a>\n<ul>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/request/get.md\">3.1 GET请求数据获取</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/request/post.md\">3.2 POST请求数据获取</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/request/post-use-middleware.md\">3.3 koa-bodyparser中间件</a></li>\n</ul>\n</li>\n<li><a href>4. 静态资源加载</a>\n<ul>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/static/server.md\">4.1 原生koa2实现静态资源服务器</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/static/middleware.md\">4.2 koa-static中间件</a></li>\n</ul>\n</li>\n<li><a href>5. cookie/session</a>\n<ul>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/cookie/info.md\">5.1 koa2使用cookie</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/session/info.md\">5.2 koa2实现session</a></li>\n</ul>\n</li>\n<li><a href>6. 模板引擎</a>\n<ul>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/template/add.md\">6.1 koa2加载模板引擎</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/template/ejs.md\">6.2 ejs模板引擎</a></li>\n</ul>\n</li>\n<li><a href>7. 文件上传</a>\n<ul>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/upload/busboy.md\">7.1 busboy模块</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/upload/simple.md\">7.2 上传文件简单实现</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/upload/pic-async.md\">7.3 异步上传图片实现</a></li>\n</ul>\n</li>\n<li><a href>8. 数据库mysql</a>\n<ul>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/mysql/info.md\">8.1 mysql模块</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/mysql/async.md\">8.2 async/await封装使用mysql</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/mysql/init.md\">8.3 项目建表初始化</a></li>\n</ul>\n</li>\n<li><a href>9. JSONP实现</a>\n<ul>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/jsonp/info.md\">9.1 原生koa2实现JSONP</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/jsonp/koa-jsonp.md\">9.2 koa-jsonp中间件</a></li>\n</ul>\n</li>\n<li><a href>10. 测试</a>\n<ul>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/test/unit.md\">10.1 单元测试</a></li>\n</ul>\n</li>\n<li><a href>11. debug</a>\n<ul>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/debug/info.md\">11.1 开发debug</a></li>\n</ul>\n</li>\n<li><a href>12. 项目框架搭建</a>\n<ul>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/project/start.md\">12.1 快速启动</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/project/framework.md\">12.2 框架设计</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/project/layer.md\">12.3 分层操作</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/project/sql.md\">12.4 数据库设计</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/project/route.md\">12.5 路由设计</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/project/webpack2.md\">12.6 webpack2环境搭建</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/project/react.md\">12.7 使用react.js</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/project/sign.md\">12.8 登录注册功能实现</a></li>\n<li><a href=\"https://github.com/ChenShenhai/koa2-note/blob/master/note/project/session.md\">12.9 session登录态判断处理</a></li>\n</ul>\n</li>\n</ul>\n<h2>前言</h2>\n<ul>\n<li>ES6/7 带来的变革</li>\n</ul>\n<p>自ES6确定和ES7的async/await开始普及，node.js的发展变得更加迅速，可以预见到JavaScript中令人“头疼”的多层嵌套回调（注意是”多层嵌套回调“）将会使用Promise + async/await的方式逐渐替代（不是完全替代，多层嵌套回调也有其特殊的应用场景）。</p>\n<ul>\n<li>koa2 大势所趋的前景</li>\n</ul>\n<p>基于async/await实现中间体系的koa2框架将会是是node.js web开发方向大势所趋的普及框架。基于generator/yield的koa1将会逐渐被koa2替代，毕竟使用co.js来处理generator是一种过渡的方式，虽然有其特定的应用场景，但是用async/await会更加优雅地实现同步写法。</p>\n<h2>初衷</h2>\n<ul>\n<li>写笔记目的</li>\n</ul>\n<p>从学生到工作写了几年的代码，觉得虽然学习新语言，新框架的主要目的是为了解决实际问题，其中更重要的是要每次入门了一门新技术后要及时留下点学习的痕迹，方便以后忘记可以从学习轨迹中迅速上手。</p>\n</div>","title":"《koa2进阶学习笔记》写了关于koa2入门教程的书【持续更新...】","last_reply_at":"2018-01-21T12:13:52.179Z","good":false,"top":false,"reply_count":36,"visit_count":28918,"create_at":"2017-02-21T16:00:14.030Z","author":{"loginname":"ChenShenhai","avatar_url":"https://avatars3.githubusercontent.com/u/8216630?v=4&s=120"}},{"id":"5a5ff20d9d371d4a059eebbe","author_id":"5a5ff1869288dc8153287f0b","tab":"ask","content":"<div class=\"markdown-text\"><p>Node Version: v8.9.3\nEgg Version: v2.0.0</p>\n<p>在使用eggjs框架时遇到如下的问题，\n<strong>我的测试环境</strong>\n/etc/hosts\n10.200.33.33 <a href=\"http://haha.ttt.com\">haha.ttt.com</a> 映射到测试服务器</p>\n<p>在代码中controller层向该地址请求数据\n<code>ctx.curl('http://haha.ttt.com', opts);</code>\n这里url是nginx服务器的域名，因为是测试环境，所以配置了hosts映射，但此时发出的请求，会返回404，\n感觉像是nginx反向代理无法生效</p>\n<p>直接在环境中使用curl命令去请求域名是可以代理成功的，\n但在代码中使用域名就会返回404，和curl直接请求IP是一样的情况，很困惑。。。</p>\n</div>","title":"使用egg.js过程中遇到的问题：curl请求到nginx服务器，但目标的反向代理无法生效","last_reply_at":"2018-01-21T11:52:46.488Z","good":false,"top":false,"reply_count":7,"visit_count":347,"create_at":"2018-01-18T01:02:05.280Z","author":{"loginname":"HOTTIN","avatar_url":"https://avatars2.githubusercontent.com/u/12428754?v=4&s=120"}},{"id":"5a6415cdafa0a121784a8e15","author_id":"5892cc297274550b057a5cad","tab":"ask","content":"<div class=\"markdown-text\"><p>在跑egg-passport-github 的 demo 的时候，发现是直接 egg 的router进行视图渲染的，想问下如何在前后端分离的情况下，怎么做 github 登录</p>\n<p>在 login.vue 里 直接 location.assign(‘<a href=\"http://127.0.0.1:7001/api/passport/github\">http://127.0.0.1:7001/api/passport/github</a>’) 这样可以跳转到github授权，但是callback之后又到egg的router里面了，如何再返回到前端并将 user info带回到前端呢？ctx.body = ctx.user;</p>\n<p>求指教。</p>\n</div>","title":"前后端分离(vue + egg) 如何使用egg-passport-github","last_reply_at":"2018-01-21T10:47:47.353Z","good":false,"top":false,"reply_count":1,"visit_count":139,"create_at":"2018-01-21T04:23:41.722Z","author":{"loginname":"EryouHao","avatar_url":"https://avatars0.githubusercontent.com/u/17328747?v=4&s=120"}},{"id":"5a6169cf9d371d4a059eec38","author_id":"584139e9539c22b15689981c","tab":"ask","content":"<div class=\"markdown-text\"><p>我们的业务需求，需要创建N多个小文件，每个文件里存一个json对象。\n一般的做法是：拿到json对象，stringify，然后以字符串形式存到一个特定的文件里。需要的时候再从特定的文件里读出来，parse一下，然后再用。</p>\n<p>请问，有没有某个包，更优雅的实现这个操作啊？\n多谢。</p>\n</div>","title":"请问，有哪个包可以方便的“存取”一个大的json对象到一个文件里？","last_reply_at":"2018-01-21T10:20:25.689Z","good":false,"top":false,"reply_count":15,"visit_count":280,"create_at":"2018-01-19T03:45:19.072Z","author":{"loginname":"hz0324","avatar_url":"https://avatars0.githubusercontent.com/u/5040078?v=4&s=120"}},{"id":"5a62125cce45d44045146198","author_id":"576a5d4063075514079b77e7","tab":"ask","content":"<div class=\"markdown-text\"><p>在我的个人博客后台系统，去拉取文章列表的时候，由于返回的document 有几百k, 足足用了10s. 单个文章的document 也有可能上百kb。这种情况下，mongodb有什么相应的优化或提高性能的办法么。是否可以通过document gzip 处理？\n<img src=\"//dn-cnode.qbox.me/FklKhLppqDayll1QP8f5I7ekAHb-\" alt=\"WechatIMG449.jpeg\"></p>\n</div>","title":"mongodb 几百kb document 请求返回过慢优化","last_reply_at":"2018-01-21T06:59:55.536Z","good":false,"top":false,"reply_count":4,"visit_count":199,"create_at":"2018-01-19T15:44:28.295Z","author":{"loginname":"MaelWeb","avatar_url":"https://avatars1.githubusercontent.com/u/7869311?v=4&s=120"}},{"id":"5a5c1c75a3692d014f4f147f","author_id":"4efc278525fa69ac69000141","tab":"ask","content":"<div class=\"markdown-text\"><p>在浏览器环境习惯了, 记不起来 Node.js 以前是不是这样.\n我的想法是把一些逻辑放在 setTimeout 的事件队列当中执行, 这样代码报错了, 主进程不受到影响, 而报错是直接打印在 Console 里的. 可是实际测试了一下, setTimeout 当中代码报错, 整个 Node.js 进程直接退出了.\n除了 try/catch 还有没有方式可以在 Node.js 当中模拟浏览器的行为? Node.js 当中一开始就这样吗?</p>\n<p>示例代码:</p>\n<pre class=\"prettyprint language-js\"><code>var http = require(&#x27;http&#x27;);\n\nhttp.createServer(function(req, res) {\n  return a(2);\n}).listen(3000);\n</code></pre></div>","title":"setTimeout 报错导致整个进程退出, 是正常行为吗","last_reply_at":"2018-01-21T06:08:31.848Z","good":false,"top":false,"reply_count":3,"visit_count":361,"create_at":"2018-01-15T03:13:57.527Z","author":{"loginname":"jiyinyiyong","avatar_url":"https://avatars0.githubusercontent.com/u/449224?v=4&s=120"}},{"id":"5a54132299d207fa49f5cd33","author_id":"5595d50047e6bdc30297ed1a","tab":"share","content":"<div class=\"markdown-text\"><p>DoraCMS 之前的版本是缺少用户发布文章这个功能的，之前不愿意加，主要是因为还没准备好做成类似论坛的模式，而只是简单的内容发布系统。考虑到前台会员发布信息的需求比较多，这次版本更新加上了，希望可以给各位建站带来便利。</p>\n<p>本次版本发布主要更新点：</p>\n<p>1、用户中心添加文章功能，注册用户可以发布文章了，支持markdown语法</p>\n<p>2、优化webpack打包流程，压缩lodash，拆分element-ui</p>\n<p>3、服务端异常处理</p>\n<p>4、用户留言xss处理</p>\n<p>5、修复文章点击量不准确的问题</p>\n<p>6、修复在开发环境下，后台切换登录超级管理员和测试管理员，左侧菜单没有变化的问题</p>\n<p>7、首页添加了用户留言模块，以及推荐模块</p>\n<p>8、优化相关样式和界面布局</p>\n<p>9、修复了其它bug</p>\n<p>更新方法：</p>\n<p>1、checkout 最新 2.0.5 代码</p>\n<p>2、删除 node_modules,重新安装依赖包</p>\n<p>3、启动数据库，执行npm run dev</p>\n<p>你可以到github上获取到最新版本的代码： <a href=\"https://github.com/doramart/DoraCMS\">DoraCMS</a></p>\n</div>","title":"DoraCMS v2.0.5 发布，Node.js CMS 内容管理框架","last_reply_at":"2018-01-21T03:58:40.263Z","good":false,"top":false,"reply_count":3,"visit_count":567,"create_at":"2018-01-09T00:56:02.654Z","author":{"loginname":"doramart","avatar_url":"https://avatars1.githubusercontent.com/u/11911066?v=4&s=120"}},{"id":"5a6303479288dc8153287fe1","author_id":"5909444b782dbc4b183ecfe2","tab":"share","content":"<div class=\"markdown-text\"><p>最近在研究P2P技术，奈何相关资料不多，自己琢磨了一下，分享一下学习P2P的一些原理, 以及如何打造一个P2P聊天应用。</p>\n<p>这里指的P2P是指<strong>peer to peer</strong>， 点对点的技术， 每个客户端都是服务端，没有中心服务器，不是websocket针对某个connection推送消息。</p>\n<h3>技术要点</h3>\n<ul>\n<li>udp协议</li>\n<li>节点之间的建立，连接和广播</li>\n<li>内网穿透，如何能让两个处在内网的节点，相互发现自己的存在，并且建立通信</li>\n</ul>\n<h3>原理</h3>\n<p>首先解决的是内网穿透的问题，常见的底层协议tcp，udp，他们各自有优缺点，简单说明一下。\ntcp：需要处理粘包问题，双工流通道，是可靠的链接。\nudp： 每次发送的都是数据包，没有粘包问题，但是连接不可靠，只能传输少量数据</p>\n<p>更加详细的请Google</p>\n<p>这里选择udp协议，简单一些。</p>\n<p>再下来是内网穿透，先说结论： <strong>两个处于不同内部网络的节点，永远无法发现他们之间的相互存在</strong>，你就算是想顺着网线过去打他都不行。</p>\n<p>所有的内网穿透原理无外乎需要一个有公网ip的中介服务器，包括虚拟货币像比特币之类的，所以首先要有一个<strong>创世节点</strong></p>\n<p>在NodeJS中，创建udp服务也很简单</p>\n<pre class=\"prettyprint language-javascript\"><code>const dgram = require(&quot;dgram&quot;);\nconst udp = dgram.createSocket(&quot;udp4&quot;);\nudp.bind(1090, callback)\n</code></pre><p>把服务部署要公网，那么其他所有的节点都能访问，通过中转服务器，能够使得两个节点可以建立连接</p>\n<p><img src=\"//dn-cnode.qbox.me/FsnZMj1j1jTUVChZ3KxqtJtty5mq\" alt=\"节点.png\"></p>\n<p>我们是要建立这样的P2P网络</p>\n<p><img src=\"//dn-cnode.qbox.me/FmJ2Ugbj3OOVqzkKeG-qpRJyvGC6\" alt=\"网络.png\"></p>\n<p>假如现在只有3个节点： <strong>创世节点</strong>,  <strong>B节点</strong>,  <strong>C节点</strong>， 创世节点有公网IP</p>\n<p>我用对话的形式，阐述他们建立链接的过程:</p>\n<blockquote>\n<p>B节点: hey，创世节点，我要加入到P2P网络里面，告诉其他兄弟，我来了\n创世节点: 兄弟们，刚刚有个叫做B的节点加入网络了，你们也去告诉其他节点\n其他节点: 刚刚收到来自 &quot;创世节点&quot;的通知，有个fresh meet加入网络了，叫做 “B”</p>\n</blockquote>\n<p>…\n至此，所有人都知道了B节点加入了网络，里面记载着B节点的相关信息，包括IP地址，包括udp端口号</p>\n<p>此时C节点也要加入网络，并且想要和B节点对话:</p>\n<blockquote>\n<p>C节点: hey，创世节点，我要加入到P2P网络里面，并且我要和B对话\n创世节点: 兄弟们，刚刚有个叫做B的节点加入网络了，你们也去告诉其他节点，顺便看看有没有B这个节点\n其他节点: 刚刚收到来自 &quot;创世节点&quot;的通知，有个fresh meet加入网络了，叫做 “C”，你们也看看有没有B这个节点\n其他节点2: 收到通知，听说一个叫做C的节点在找一个B节点，我这里有它的信息，ip是xxxx.xxxx.xxx.xxxx, 端口10086\nB节点: 有个C的家伙(ip: xxxx.xxxx.xxxx.xxxx, 端口1000)要找我</p>\n</blockquote>\n<p>到这里，B获取到了C的信息，包括IP和端口，C也拿到了B的信息.</p>\n<p>于是，他们两个就可以建立通信。消息流: B &lt;----&gt; C. 中间不经过任何服务器</p>\n<p>用一张图来形容:</p>\n<p><img src=\"//dn-cnode.qbox.me/FrJP9zk_RzD5PSTIHhDoSQUzZB85\" alt=\"new.png\"></p>\n<h3>总结</h3>\n<p>在设计中，每个节点的功能都是一样的。如果需要加入到网络中，不一定跟创世节点链接</p>\n<p>假设已存在的节点: 创世节点，A、B、C节点，此时有个D节点想要加入到网络。</p>\n<p>那么D节点不一定非得链接到创世节点，可以链接到A、B、C中的任意一个节点，然后该节点再广播给其他节点说&quot;Hey, 有个新人叫做D的加入了网络&quot;。</p>\n<p>这样所有人都知道，有个叫做D的节点存在，你可以和它通信，同时D节点和会同步已存在的节点。这样D节点也知道了其他节点的存在了。</p>\n<h3>最后</h3>\n<p>基于这一原理，可以打造出一个P2P的聊天应用，没有中间商赚差价。</p>\n<p>这只是一些基本原理，离实际应用还差很多，有很多坑，比如D节点退出网络之后，要广播 “D节点退出网络了，把这个节点注销了吧，这波没他&quot;，还有消息加密，通信的双向验证(A节点想要B节点通信，但是不需要B节点的同意)等等，坑太多，填不完</p>\n<p>原计划是搭建这么一个网络，然后写个electron的聊天应用，但是精力有限，就这样了。<a href=\"https://github.com/axetroy/p2p-chat\">代码</a>(写的丑，轻拍)</p>\n<p>文字功底有点差，表述不清楚，见谅，如文中有误，欢迎指正与交流。</p>\n<p><img src=\"http://i01.pic.sogou.com/9ffb608227cf81da\" alt></p>\n<p>年后正在找一份NodeJS的工作，坐标深圳，哪里能投递</p>\n</div>","title":"搭建P2P网络的原理","last_reply_at":"2018-01-21T03:25:59.904Z","good":false,"top":false,"reply_count":4,"visit_count":218,"create_at":"2018-01-20T08:52:23.029Z","author":{"loginname":"axetroy","avatar_url":"https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"}},{"id":"5930cf8203dba3510d8a62e1","author_id":"5779db49fb1d649f05fec70b","tab":"share","content":"<div class=\"markdown-text\"><h4>什么是jwt</h4>\n<p>这个文章已经解释得很清楚了<a href=\"http://www.jianshu.com/p/576dbf44b2ae\">传送门</a></p>\n<h4>jwt和session的区别</h4>\n<p><strong>session</strong>：一般用于服务端存储信息，其生命周期会随服务器重启而终止，或者由代码清除。\n常常用于web应用登录状态的保存，但是在ios/android应用中，网络请求不包含session信息，因此服务端session无法使用，这是就产生了token。\n<strong>token</strong>：作为用户状态的凭证。用户登录成功后，服务端生成一条token信息，该token可以包含用户id，过期时间等信息，经过加密算法返回给客户端，客户端访问时将该token带上，服务端做权限校验。</p>\n<h4>废话少说，直接上代码</h4>\n<p><strong>auth.service.js核心代码，用于生成token和验证token：</strong>\n1、安装express-jwt <a href=\"https://github.com/auth0/express-jwt\">github地址</a>\n2、定义产生token方法，role为附加信息，用来做角色权限控制\nconfig.secrets.session为密钥，一个字符串。</p>\n<pre class=\"prettyprint\"><code>module.exports.signToken = (id, role) =&gt; {\n    return jwt.sign({_id: id, role}, config.secrets.session, {\n        expiresIn: 60 * 60 * 5 &#x2F;&#x2F; 过期时间 表示5小时过期\n    })\n}\n</code></pre><p>3、定义验证token方法isAuthenticated，以下是截取部分关键代码。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 从请求头获取token\nvar token = req.headers.authorization.split(&#x27;Bearer &#x27;)[1]\n      &#x2F;&#x2F; 查找数据库是否有该token\n      UserController.findByToken(token).then((user) =&gt; {\n      if (user) {\n       &#x2F;&#x2F;验证token是否过期\n         validateJwt(req, res, next);\n       }else{\n         return res.status(401).end();\n      }\n })\n</code></pre><p><strong>开发登录和权限验证功能：</strong>\n1、定义登录方法</p>\n<pre class=\"prettyprint\"><code>module.exports.login = (req, res) =&gt; {\n  var loginId = req.body.loginId\n  var password = req.body.password\n  let token\n&#x2F;&#x2F; 数据库查找用户\n  return User.findOne({ loginId: loginId }).exec()\n    .then(user =&gt; {\n   &#x2F;&#x2F; 验证密码是否正确\n      if (user &amp;&amp; user.authenticate(password)) {\n   &#x2F;&#x2F; 产生token\n        token = jwt.sign({ _id: user._id }, config.secrets.session, {\n          expiresIn: 60 * 60 * 5\n        })\n        user.token = token\n        var updateUser = JSON.parse(JSON.stringify(user))\n        delete updateUser._id\n        User.findOneAndUpdate({ _id: user._id }, updateUser).exec()\n        &#x2F;&#x2F; 返回给客户端\n        res.status(200).json({ token }).end()\n      } else {\n        return res.status(401).end()\n      }\n    })\n}\n</code></pre><p>2、验证用户身份，参考auth.service.js isAuthenticated方法</p>\n<h4>问题来了</h4>\n<p><strong>如何刷新token?</strong>\nexpress-jwt这个库没有提供刷新token过期时间的方法，因此我们需要后端重新创建token，让客户端更新token。为了保证安全性，我们不能因token失效就刷新，那这样token就有可能被黑客嗅探利用。\n因此，解决方案应该是当token过期时间小于一小时，后端返回新的token，token放在返回头，当前端发现返回头带有token信息，即更新token。\n当token已经过期，就返回401，提示用户重新登录。</p>\n<h4>项目源码  <a href=\"https://github.com/zhengguorong/h5maker\">github地址</a></h4>\n<h4>项目演示</h4>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/6276836-272dadde2340c8fe.gif?imageMogr2/auto-orient/strip\" alt=\"项目演示\"></p>\n</div>","title":"jwt在node中的应用","last_reply_at":"2018-01-21T03:18:19.862Z","good":false,"top":false,"reply_count":10,"visit_count":1995,"create_at":"2017-06-02T02:37:54.756Z","author":{"loginname":"zhengguorong","avatar_url":"https://avatars0.githubusercontent.com/u/2757932?v=4&s=120"}},{"id":"5a63ff23afa0a121784a8e10","author_id":"5a38ceb89807389a1809f52a","tab":"ask","content":"<div class=\"markdown-text\"><p>2018也过去了二十天了。但好像没有看到关于Node.js的总结和发展展望,如果可以的话还是希望有大佬做一下。指导新人下一步的学习(哪些技术正在兴起,重点学习,哪些技术在衰落,可以放一边)</p>\n</div>","title":"有没有大佬做一份Node.js在2017的发展总结和2018展望？","last_reply_at":"2018-01-21T02:46:59.489Z","good":false,"top":false,"reply_count":0,"visit_count":162,"create_at":"2018-01-21T02:46:59.489Z","author":{"loginname":"JeromeYangtao","avatar_url":"https://avatars1.githubusercontent.com/u/22118243?v=4&s=120"}},{"id":"5a609e28ce45d44045146131","author_id":"59f9da9ab381c1737d7ccb9f","tab":"ask","content":"<div class=\"markdown-text\"><p>egg-socket.io里怎么监听connect event啊😑😑</p>\n</div>","title":"egg-socket.io里怎么监听connect event啊😑😑","last_reply_at":"2018-01-20T16:28:27.301Z","good":false,"top":false,"reply_count":2,"visit_count":227,"create_at":"2018-01-18T13:16:24.648Z","author":{"loginname":"Alexerx","avatar_url":"https://avatars3.githubusercontent.com/u/22076610?v=4&s=120"}},{"id":"5a63646dce45d440451461c3","author_id":"541868cee97164b2570193f6","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>原文地址：<a href=\"https://github.com/hongmaoxiao/myblog/issues/8\">JavaScript30秒， 从入门到放弃之Array（四）</a></p>\n<p>博客地址：<a href=\"https://fengxiaomao.com/#/article/33\">JavaScript30秒， 从入门到放弃之Array（四）</a></p>\n<p>水平有限，欢迎批评指正</p>\n</blockquote>\n<h2>maxN</h2>\n<blockquote>\n<p>Returns the <code>n</code> maximum elements from the provided array. If <code>n</code> is greater than or equal to the provided array’s length, then return the original array(sorted in descending order).</p>\n<p>Use <code>Array.sort()</code> combined with the spread operator (<code>...</code>) to create a shallow clone of the array and sort it in descending order. Use <code>Array.slice()</code> to get the specified number of elements. Omit the second argument, <code>n</code>, to get a one-element array.</p>\n<pre class=\"prettyprint language-javascript\"><code>const maxN = (arr, n = 1) =&gt; [...arr].sort((a, b) =&gt; b - a).slice(0, n);\n</code></pre></blockquote>\n<p>返回一个数组的前n个最大值，如果指定的<code>n</code>大于或等于指定数组的长度，那么将返回原数组（按降序排列后）。</p>\n<p>使用<code>Array.sort()</code>和<code>ES6</code>的扩展运算符<code>…</code>来生成一个按降序排列的浅度复制数组。使用<code>Array.slice()</code>来截取指定个数的数组元素。若省略第二个参数<code>n</code>时，<code>n=1</code>。</p>\n<pre class=\"prettyprint language-javascript\"><code>➜  code cat maxN.js\nconst maxN = (arr, n = 1) =&gt; [...arr].sort((a, b) =&gt; b - a).slice(0, n);\n\nconsole.log(maxN([1, 2, 3]));\nconsole.log(maxN([1, 2, 3], 2));\n\n➜  code node maxN.js\n[ 3 ]\n[ 3, 2 ]\n</code></pre><p>主要看懂这个<code>sort</code>就好了：</p>\n<pre class=\"prettyprint language-javascript\"><code>sort((a, b) =&gt; b - a)\n</code></pre><p>这是降序排的方法，怎么讲？</p>\n<p>变形一：</p>\n<pre class=\"prettyprint language-javascript\"><code>sort(fn(a，b))\n</code></pre><p>这个<code>fn</code>呢有两个参数<code>a</code>、<code>b</code>就是数组排序是按顺序相邻的两个数组元素。<code>a</code>前、<code>b</code>后。</p>\n<p>变形二：</p>\n<pre class=\"prettyprint language-javascript\"><code>sort((a, b) =&gt; {\n  if (b &gt; a) {\n    return 1;\n  } else if (b &lt; a) {\n    return -1;\n  }\n  return 0;\n})\n</code></pre><p>return<code>1</code>表示把前面的数<code>a</code>放后面，后面的数<code>b</code>在放前面；return<code>0</code>表示不换位置；return<code>-1</code>表示前面的数<code>a</code>放前面，后面的数<code>b</code>放后面。</p>\n<p>例子中，当<code>b &gt; a</code>时把<code>a</code>换到<code>b</code>后面，意即把大数放前边了，即降序排列。反之升序排列。</p>\n<pre class=\"prettyprint language-javascript\"><code>slice(0, n)\n</code></pre><p>排完之后<code>slice(0, n)</code>截取前<code>n</code>个元素组成的数组即为数组最大的前<code>n</code>个数。</p>\n<h2>minN</h2>\n<blockquote>\n<p>Returns the <code>n</code> minimum elements from the provided array. If <code>n</code> is greater than or equal to the provided array’s length, then return the original array(sorted in ascending order).</p>\n<p>Use <code>Array.sort()</code> combined with the spread operator (<code>...</code>) to create a shallow clone of the array and sort it in ascending order. Use <code>Array.slice()</code> to get the specified number of elements. Omit the second argument, <code>n</code>, to get a one-element array.</p>\n<pre class=\"prettyprint language-javascript\"><code>const minN = (arr, n = 1) =&gt; [...arr].sort((a, b) =&gt; a - b).slice(0, n);\n</code></pre></blockquote>\n<p>返回一个数组的前n个最小值，如果指定的<code>n</code>大于或等于指定数组的长度，那么将返回原数组（按升序排列后）。</p>\n<p>使用<code>Array.sort()</code>和<code>ES6</code>的扩展运算符<code>…</code>来生成一个按升序排列的浅度复制数组。使用<code>Array.slice()</code>来截取指定个数的数组元素。若省略第二个参数<code>n</code>时，<code>n=1</code>。</p>\n<pre class=\"prettyprint language-javascript\"><code>➜  code cat minN.js\nconst maxN = (arr, n = 1) =&gt; [...arr].sort((a, b) =&gt; a - b).slice(0, n);\n\nconsole.log(maxN([1, 2, 3]));\nconsole.log(maxN([1, 2, 3], 2));\n\n➜  code node minN.js\n[ 1 ]\n[ 1, 2 ]\n</code></pre><p><code>sort((a, b) =&gt; a - b)</code>与<code>maxN</code>相反，命题得证！</p>\n<h2>nthElement</h2>\n<blockquote>\n<p>Returns the nth element of an array.</p>\n<p>Use <code>Array.slice()</code> to get an array containing the nth element at the first place. If the index is out of bounds, return <code>[]</code>. Omit the second argument, <code>n</code>, to get the first element of the array.</p>\n<pre class=\"prettyprint language-javascript\"><code>const nthElement = (arr, n = 0) =&gt; (n &gt; 0 ? arr.slice(n, n + 1) : arr.slice(n))[0];\n</code></pre></blockquote>\n<p>返回指定数组的第<code>n</code>个元素（索引从0算起）。</p>\n<p>使用<code>Array.slice()</code>截取数组，使截取的数组的第一个元素就是<code>nth</code>对应的元素。如果索引<code>n</code>超过数组范围，返回空数组<code>[]</code>。省略第二个参数<code>n</code>，按<code>n=0</code>计。</p>\n<pre class=\"prettyprint language-javascript\"><code>➜  code cat nthElement.js\nconst nthElement = (arr, n = 0) =&gt; (n &gt; 0 ? arr.slice(n, n + 1) : arr.slice(n))[0];\n\nconsole.log(nthElement([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], 1));\nconsole.log(nthElement([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;], -3));\n\n➜  code node nthElement.js\nb\na\n</code></pre><p>就是简单的用<code>slice</code>去截取元素，取截取后的第一个元素即可。</p>\n<h2>partition</h2>\n<blockquote>\n<p>Groups the elements into two arrays, depending on the provided function’s truthiness for each element.</p>\n<p>Use <code>Array.reduce()</code> to create an array of two arrays. Use <code>Array.push()</code> to add elements for which <code>fn</code> returns <code>true</code> to the first array and elements for which <code>fn</code> returns <code>false</code> to the second one.</p>\n<pre class=\"prettyprint language-javascript\"><code>const partition = (arr, fn) =&gt;\n  arr.reduce(\n    (acc, val, i, arr) =&gt; {\n      acc[fn(val, i, arr) ? 0 : 1].push(val);\n      return acc;\n    },\n    [[], []]\n  );\n</code></pre></blockquote>\n<p>根据提供的方法对一个数组就行调用后，按运算结果的布尔值是否为真分类。为真，归到二维数组索引为0的数组中；为假，归到二维数组索引为1的数组中。</p>\n<p>使用<code>Array.reduce()</code>生成一个<code>1x2</code>的二维数组。使用<code>Array.push()</code>把指定<code>fn</code>运算结果为<code>true</code>的数组元素添加到二维数组的第一个数组中，运算结果为<code>false</code>的数组元素添加到二维数组的第二个数组中。</p>\n<pre class=\"prettyprint language-javascript\"><code>➜  code cat partition.js\nconst partition = (arr, fn) =&gt; arr.reduce((acc, val, i, arr) =&gt; {\n    acc[fn(val, i, arr) ? 0 : 1].push(val);\n    return acc;\n}, [\n    [],\n    []\n]);\n\nconst users = [{\n    user: &#x27;Pony&#x27;,\n    age: 47,\n    active: true\n}, {\n    user: &#x27;barney&#x27;,\n    age: 36,\n    active: false\n}, {\n    user: &#x27;fred&#x27;,\n    age: 40,\n    active: true\n}];\n\nconsole.log(partition(users, o =&gt; o.active));\n\n➜  code node partition.js\n[ [ { user: &#x27;Pony&#x27;, age: 47, active: true },\n    { user: &#x27;fred&#x27;, age: 40, active: true } ],\n  [ { user: &#x27;barney&#x27;, age: 36, active: false } ] ]\n</code></pre><p><code>acc</code>的默认值是一个<code>1x2</code>的二维空数组<code>[[], []]</code>。随着<code>reduce</code>的遍历过程将把满足对应条件的元素分别<code>push</code>到对应的数组中。</p>\n<pre class=\"prettyprint\"><code>acc[fn(val, i, arr) ? 0 : 1].push(val);\n</code></pre><p><code>fn(val, i, arr)</code>如果为<code>true</code>将会把对应的元素<code>val</code>添加到<code>acc</code>的索引为<code>0</code>的数组中，否则添加到索引为<code>1</code>的数组中。这样遍历结束就达到了分组的目的。</p>\n<p>例子中，<code>fn</code>是<code>o =&gt; o.active</code>就是根据对象的<code>active</code>的属性是否为<code>true</code>进行分类，所以我们看到，<code>user</code>为<code>Pony</code>和<code>fred</code>的元素都在二维数组的索引为0的数组中，其它在二维数组的索引为1的数组中。</p>\n<h2>pull</h2>\n<blockquote>\n<p>Mutates the original array to filter out the values specified.</p>\n<p>Use <code>Array.filter()</code> and <code>Array.includes()</code> to pull out the values that are not needed. Use <code>Array.length = 0</code> to mutate the passed in an array by resetting it’s length to zero and <code>Array.push()</code> to re-populate it with only the pulled values.</p>\n<p><em>(For a snippet that does not mutate the original array see without)</em></p>\n<pre class=\"prettyprint language-javascript\"><code>const pull = (arr, ...args) =&gt; {\n let argState = Array.isArray(args[0]) ? args[0] : args;\n let pulled = arr.filter((v, i) =&gt; !argState.includes(v));\n arr.length = 0;\n pulled.forEach(v =&gt; arr.push(v));\n};\n</code></pre></blockquote>\n<p>改变原数组使其过滤掉指定的那些元素。</p>\n<p>使用<code>Array.filter()</code>和<code>Array.includes()</code>剔除数组里不需要的元素。先用<code>Array.length = 0</code>把原数组变成空数组，然后再通过<code>Array.push()</code>把过滤后剩余的元素重新填充进去。</p>\n<p><em>（类似方法不改变原数组的请看without方法）</em></p>\n<pre class=\"prettyprint language-javascript\"><code>➜  code cat pull.js\nconst pull = (arr, ...args) =&gt; {\n    let argState = Array.isArray(args[0]) ? args[0] : args;\n    let pulled = arr.filter((v, i) =&gt; !argState.includes(v));\n    arr.length = 0;\n    pulled.forEach(v =&gt; arr.push(v));\n};\n\nlet myArray = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];\npull(myArray, &#x27;a&#x27;, &#x27;c&#x27;);\nlet secondArray = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];\npull(secondArray, [&#x27;a&#x27;, &#x27;c&#x27;], &#x27;b&#x27;);\n\nconsole.log(myArray);\nconsole.log(secondArray);\n\n➜  code node pull.js\nargs:  [ &#x27;a&#x27;, &#x27;c&#x27; ]\nargs:  [ [ &#x27;a&#x27;, &#x27;b&#x27; ], &#x27;c&#x27; ]\n[ &#x27;b&#x27;, &#x27;b&#x27; ]\n[ &#x27;c&#x27;, &#x27;c&#x27; ]\n</code></pre><pre class=\"prettyprint language-javascript\"><code>let argState = Array.isArray(args[0]) ? args[0] : args;\n</code></pre><p>判断<code>args</code>的第一个元素是不是一个数组，如果是，把该数组赋值给<code>argState</code>作为后续排除数组元素的元数组；否则<code>args</code>就是元数组。</p>\n<pre class=\"prettyprint language-javascript\"><code>let pulled = arr.filter((v, i) =&gt; !argState.includes(v));\n</code></pre><p>结合<code>filter</code>和<code>includes</code>把数组<code>arr</code>中包含在<code>argState</code>中的元素排除掉。</p>\n<pre class=\"prettyprint language-javascript\"><code>arr.length = 0;\npulled.forEach(v =&gt; arr.push(v));\n</code></pre><p>此处，把数组长度设为0，将数组置空，然后再遍历<code>pulled</code>，把所有<code>pulled</code>的元素<code>push</code>到<code>arr</code>中，最终<code>arr</code>就只含有排除掉指定元素后的其他元素。</p>\n<h2>pullAtIndex</h2>\n<blockquote>\n<p>Mutates the original array to filter out the values at the specified indexes.</p>\n<p>Use <code>Array.filter()</code> and <code>Array.includes()</code> to pull out the values that are not needed. Use <code>Array.length = 0</code> to mutate the passed in an array by resetting it’s length to zero and <code>Array.push()</code> to re-populate it with only the pulled values. Use <code>Array.push()</code> to keep track of pulled values</p>\n<pre class=\"prettyprint language-javascript\"><code>const pullAtIndex = (arr, pullArr) =&gt; {\n let removed = [];\n let pulled = arr\n   .map((v, i) =&gt; (pullArr.includes(i) ? removed.push(v) : v))\n   .filter((v, i) =&gt; !pullArr.includes(i));\n arr.length = 0;\n pulled.forEach(v =&gt; arr.push(v));\n return removed;\n};\n</code></pre></blockquote>\n<p>改变原数组使其过滤掉指定的那些索引值对应的元素。</p>\n<p>使用<code>Array.filter()</code>和<code>Array.includes()</code>剔除数组里不需要的元素。先用<code>Array.length = 0</code>把原数组变成空数组，然后再通过<code>Array.push()</code>把过滤后剩余的元素重新填充进去。同时使用<code>Array.push()</code>跟踪记录剔除掉的所有元素。</p>\n<pre class=\"prettyprint language-javascript\"><code>➜  code cat pullAtIndex.js\nconst pullAtIndex = (arr, pullArr) =&gt; {\n    let removed = [];\n    let pulled = arr.map((v, i) =&gt; (pullArr.includes(i) ? removed.push(v) : v))\n        .filter((v, i) =&gt; !pullArr.includes(i));\n\n    arr.length = 0;\n    pulled.forEach((v) =&gt; arr.push(v));\n    return removed;\n};\n\nlet myArray = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;];\nlet pulled = pullAtIndex(myArray, [1, 3]);\n\nconsole.log(&#x27;myArray: &#x27;, myArray);\nconsole.log(&#x27;pulled: &#x27;, pulled);\n\n➜  code node pullAtIndex.js\nmyArray:  [ &#x27;a&#x27;, &#x27;c&#x27; ]\npulled:  [ &#x27;b&#x27;, &#x27;d&#x27; ]\n</code></pre><pre class=\"prettyprint language-javascript\"><code>let pulled = arr\n  .map((v, i) =&gt; (pullArr.includes(i) ? removed.push(v) : v))\n  .filter((v, i) =&gt; !pullArr.includes(i));\n</code></pre><p><code>arr</code>先<code>map</code>是为了把要排除掉的元素<code>push</code>到<code>removed</code>变量中。<code>pullArr.includes(i) ? removed.push(v) : v</code>这个三元运算符就是判断索引是否在要排除掉的指定索引数组<code>pullArr</code>中。如果在，添加到<code>removed</code>中，否则直接返回该元素。</p>\n<p>接下来<code>filter</code>把<code>arr</code>中匹配<code>pullArr</code>的索引对应元素剔除掉。</p>\n<pre class=\"prettyprint language-javascript\"><code>arr.length = 0;\npulled.forEach((v) =&gt; arr.push(v));\nreturn removed;\n</code></pre><p>最后把<code>arr</code>置空后再填入满足条件的元素，然后返回剔除掉的元素组成的数组。</p>\n<h2>pullAtValue</h2>\n<blockquote>\n<p>Mutates the original array to filter out the values specified. Returns the removed elements.</p>\n<p>Use <code>Array.filter()</code> and <code>Array.includes()</code> to pull out the values that are not needed. Use <code>Array.length = 0</code> to mutate the passed in an array by resetting it’s length to zero and <code>Array.push()</code> to re-populate it with only the pulled values. Use <code>Array.push()</code> to keep track of pulled values</p>\n<pre class=\"prettyprint language-javascript\"><code>const pullAtValue = (arr, pullArr) =&gt; {\n  let removed = [],\n    pushToRemove = arr.forEach((v, i) =&gt; (pullArr.includes(v) ? removed.push(v) : v)),\n    mutateTo = arr.filter((v, i) =&gt; !pullArr.includes(v));\n  arr.length = 0;\n  mutateTo.forEach(v =&gt; arr.push(v));\n  return removed;\n};\n</code></pre></blockquote>\n<p>改变原数组使其过滤掉指定的那些值所匹配的元素们，返回剔除掉所有元素组成的数组。</p>\n<p>使用<code>Array.filter()</code>和<code>Array.includes()</code>剔除数组里不需要的元素。先用<code>Array.length = 0</code>把原数组变成空数组，然后再通过<code>Array.push()</code>把过滤后剩余的元素重新填充进去。同时使用<code>Array.push()</code>跟踪记录剔除掉的所有元素。</p>\n<pre class=\"prettyprint language-javascript\"><code>➜  code cat pullAtValue.js\nconst pullAtValue = (arr, pullArr) =&gt; {\n    let removed = [],\n        pushToRemove = arr.forEach((v, i) =&gt; (pullArr.includes(v) ? removed.push(v) : v)),\n        mutateTo = arr.filter((v, i) =&gt; !pullArr.includes(v));\n\n    arr.length = 0;\n    mutateTo.forEach((v) =&gt; arr.push(v));\n    return removed;\n};\n\nlet myArray = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;];\nlet pulled = pullAtValue(myArray, [&#x27;b&#x27;, &#x27;d&#x27;]);\n\nconsole.log(&#x27;myArray: &#x27;, myArray);\nconsole.log(&#x27;pulled: &#x27;, pulled);\n\n➜  code node pullAtValue.js\nmyArray:  [ &#x27;a&#x27;, &#x27;c&#x27; ]\npulled:  [ &#x27;b&#x27;, &#x27;d&#x27; ]\n</code></pre><p>逻辑上和<code>pullAtIndex</code>差不多，差别就在一个是<code>过滤索引</code>，另一个是过滤<code>值</code>。</p>\n<p>为此实现上就有了以下不同：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; pullAtIndex\narr.map((v, i) =&gt; (pullArr.includes(i) ? removed.push(v) : v))\n\n&#x2F;&#x2F; pullAtValue\narr.forEach((v, i) =&gt; (pullArr.includes(v) ? removed.push(v) : v))\n</code></pre><p>一个用了<code>arr.map</code>，一个用了<code>arr.forEach</code>。</p>\n<p><strong>为什么呢？</strong></p>\n<p><code>arr.map</code>后<code>arr</code>的元素是会改变的，但是对于要剔除掉索引来说要删除掉索引对应的值是否有变化是无关紧要的。而对于匹配值来说就不灵了，因为本来要剔除掉的值在<code>map</code>的过程中改变了，到<code>filter</code>的时候就匹配不出来了，就无法剔除了。</p>\n<p>所以改成了<code>arr.forEach</code>，它是不改变数组元素的，没有副作用，不干扰后续<code>filter</code>。另外<code>forEach</code>的结果是<code>undefined</code>。</p>\n<h2>reducedFilter</h2>\n<blockquote>\n<p>Filter an array of objects based on a condition while also filtering out unspecified keys.</p>\n<p>Use <code>Array.filter()</code> to filter the array based on the predicate <code>fn</code> so that it returns the objects for which the condition returned a truthy value. On the filtered array, use <code>Array.map()</code> to return the new object using <code>Array.reduce()</code> to filter out the keys which were not supplied as the <code>keys</code> argument.</p>\n<pre class=\"prettyprint language-javascript\"><code>const reducedFilter = (data, keys, fn) =&gt;\n  data.filter(fn).map(el =&gt;\n    keys.reduce((acc, key) =&gt; {\n      acc[key] = el[key];\n      return acc;\n    }, {})\n  );\n</code></pre></blockquote>\n<p>根据一个条件对一个数组进行过滤，同时过滤掉不需要的键。</p>\n<p>使用<code>Array.filter()</code>去过滤出指定方法<code>fn</code>对数组元素对象调用结果为真值的元素，对过滤后的数组使用<code>Array.map()</code>返回一个新的对象，对象包含的键值对是由<code>Array.reduce()</code>根据指定<code>keys</code>过滤掉不需要的键而组成的。</p>\n<pre class=\"prettyprint language-javascript\"><code>➜  code cat reducedFilter.js\nconst reducedFilter = (data, keys, fn) =&gt;\n    data.filter(fn).map(el =&gt;\n        keys.reduce((acc, key) =&gt; {\n            acc[key] = el[key];\n            return acc;\n        }, {})\n    );\n\n\nconst data = [{\n    id: 1,\n    name: &#x27;john&#x27;,\n    age: 24\n}, {\n    id: 2,\n    name: &#x27;mike&#x27;,\n    age: 50\n}];\n\nconsole.log(reducedFilter(data, [&#x27;id&#x27;, &#x27;name&#x27;], item =&gt; item.age &gt; 24));\n\n➜  code node reducedFilter.js\n[ { id: 2, name: &#x27;mike&#x27; } ]\n</code></pre><pre class=\"prettyprint language-javascript\"><code>data.filter(fn)\n</code></pre><p>数组<code>data</code>根据方法<code>fn</code>过滤掉了不满足条件的数组元素。</p>\n<pre class=\"prettyprint language-javascript\"><code>keys.reduce((acc, key) =&gt; {\n  acc[key] = el[key];\n  return acc;\n}, {})\n</code></pre><p><code>keys</code>是最终要保留的键的数组，<code>reduce</code>的<code>acc</code>初始值是空对象<code>{}</code>，遍历过程中，把所有的<code>el</code>对象中键包含于<code>keys</code>数组所有键值对累加到<code>acc</code>对象中。</p>\n<pre class=\"prettyprint language-javascript\"><code>map(el =&gt; fn1)\n</code></pre><p>最后联合<code>map</code>方法可以看出，最终返回的是一个数组，数组内包含<code>fn1</code>方法也就是<code>keys.reduce</code>方法返回的<code>acc</code>的对象。</p>\n<h2>remove</h2>\n<blockquote>\n<p>Removes elements from an array for which the given function returns <code>false</code>.</p>\n<p>Use <code>Array.filter()</code> to find array elements that return truthy values and <code>Array.reduce()</code> to remove elements using <code>Array.splice()</code>. The <code>func</code> is invoked with three arguments (<code>value, index, array</code>).</p>\n<pre class=\"prettyprint language-javascript\"><code>const remove = (arr, func) =&gt;\n  Array.isArray(arr)\n    ? arr.filter(func).reduce((acc, val) =&gt; {\n        arr.splice(arr.indexOf(val), 1);\n        return acc.concat(val);\n      }, [])\n    : [];\n</code></pre></blockquote>\n<p>删除数组中以指定方法调用结果为<code>false</code>的所有元素。</p>\n<p>使用<code>Array.filter()</code>来找出数组中所有运行指定方法结果为真的元素，使用<code>Array.reduce()</code>配合<code>Array.splice()</code>删除掉不需要的元素。<code>func</code>函数调用有三个参数<code>(value, index, array)</code>。</p>\n<pre class=\"prettyprint language-javascript\"><code>➜  code cat remove.js\nconst remove = (arr, func) =&gt;\n    Array.isArray(arr) ?\n    arr.filter(func).reduce((acc, val) =&gt; {\n        arr.splice(arr.indexOf(val), 1);\n        return acc.concat(val);\n    }, []) : [];\n\nconst arr = [1,2,3,4];\nconsole.log(remove(arr, n =&gt; n % 2 == 0));\nconsole.log(arr);\n\n➜  code node remove.js\n[ 2, 4 ]\n[ 1, 3 ]\n</code></pre><pre class=\"prettyprint language-javascript\"><code>Array.isArray(arr) ? filterfun : [];\n</code></pre><p>先判断给定参数<code>arr</code>是否是一个数组，是，执行<code>filter</code>函数；否，直接返回结果空数组<code>[]</code>。</p>\n<pre class=\"prettyprint language-javascript\"><code>arr.filter(func).reduce((acc, val) =&gt; {\n  arr.splice(arr.indexOf(val), 1);\n  return acc.concat(val);\n}, [])\n</code></pre><p><code>arr.filter(func)</code>首先过滤出<code>func</code>运行结果为真所有数组元素。<code>reduce</code>方法将<code>filter</code>剩余的所有数组元素以<code>concat</code>的方式返回结果数组。而在原数组<code>arr</code>中，则用<code>splice</code>将<code>func</code>运行结果为真的所有元素剔除。</p>\n<p>其实就最终的返回结果来说，<code>arr.filter(func)</code>已经可以返回正确的结果，之所以看起来多此一举的使用了<code>reduce</code>的原因在于必须把不需要的元素从原数组<code>arr</code>中剔除。</p>\n<p>以下是我在没看代码之前根据例子运行结果先写的代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>➜  code cat remove1.js\nconst remove = (arr, fn) =&gt; {\n  let removed = [];\n  arr.forEach(v =&gt; (fn(v) ? removed.push(v) : v));\n  const left = arr.filter(v =&gt; !fn(v));\n\n  arr.length = 0;\n  left.forEach(v =&gt; arr.push(v));\n\n  return removed;\n};\n\nconst arr = [1,2,3,4];\nconsole.log(remove(arr, n =&gt; n % 2 == 0));\nconsole.log(arr);\n\n➜  code node remove1.js\n[ 2, 4 ]\n[ 1, 3 ]\n</code></pre><p>我认为代码本身应该没什么问题，但可能没那么优雅，另外就是没有做<code>Array.isArray</code>的前置条件判断。</p>\n<h2>sample</h2>\n<blockquote>\n<p>Returns a random element from an array.</p>\n<p>Use <code>Math.random()</code> to generate a random number, multiply it by <code>length</code> and round it of to the nearest whole number using <code>Math.floor()</code>. This method also works with strings.</p>\n<pre class=\"prettyprint language-javascript\"><code>const sample = arr =&gt; arr[Math.floor(Math.random() * arr.length)];\n</code></pre></blockquote>\n<p>返回数组中随机的一个元素。</p>\n<p>使用<code>Math.random()</code>生成一个随机数，乘以数组的长度，然后再配以<code>Math.floor()</code>获取整数索引，进而返回该索引对应的数组元素。这个方法也同样适用于字符串。</p>\n<pre class=\"prettyprint language-javascript\"><code>➜  code cat sample.js\nconst sample = (arr) =&gt; arr[Math.floor(Math.random() * arr.length)]\n\nconsole.log(sample([3, 7, 9, 11]));\n\n➜  code node sample.js\n7\n</code></pre></div>","title":"JavaScript30秒， 从入门到放弃之Array（四）","last_reply_at":"2018-01-20T15:46:53.656Z","good":false,"top":false,"reply_count":0,"visit_count":178,"create_at":"2018-01-20T15:46:53.656Z","author":{"loginname":"hongmaoxiao","avatar_url":"https://avatars0.githubusercontent.com/u/3943494?v=4&s=120"}},{"id":"5a604732afa0a121784a8d28","author_id":"5a5d5e809288dc8153287e4f","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FpISR8xl9cWaE5VFdT0AhJw8lZtc\" alt=\"TIM截图20180118150428.png\"></p>\n<p><a href=\"https://stackoverflow.com/questions/30452263/is-there-a-mechanism-to-loop-x-times-in-es6-ecmascript-6-without-mutable-varia\">来自这里</a></p>\n<p><strong>看到这个直接懵了，这是啥。。。。。</strong></p>\n<p><strong>用babel处理了下才算能明白</strong>\n<img src=\"//dn-cnode.qbox.me/FrWu3a9E5GETjkSqbTpe_EwjrvvV\" alt=\"TIM图片20180118143855.png\"></p>\n</div>","title":"哎呀妈呀，这ES6语法，害我想了大半个钟头！","last_reply_at":"2018-01-20T13:10:02.346Z","good":false,"top":false,"reply_count":13,"visit_count":936,"create_at":"2018-01-18T07:05:22.291Z","author":{"loginname":"baofengyv","avatar_url":"https://avatars3.githubusercontent.com/u/5669938?v=4&s=120"}},{"id":"5a5c1e399d371d4a059eeaaf","author_id":"59ddc34920a1a3647d72aaf3","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>前言：\n\t\t作为一名前端开发人员，对服务器的部署运维一直感觉很陌生，但是却兴趣盎然，所以就自己购买了一台阿里服务器来学习。接触到其实很多人在部署服务的过程中也都会或多或少的遇到很多问题（老司机除外），所以就打算把自己在部署服务器的过程中遇到的问题以及解决的过程记录下来，一来做个记录，二来可以抛砖引玉，再来大家可以一起学习。该系列文章将会从最基本的 node 、mongo 环境安装讲起，逐步深入，最终通过 docker 实现服务的自动构建和部署。\n\t\t本篇作为系列文章的首篇，主要介绍 node、mongo 及 nginx 的安装。注：笔者的服务器为 CentOS 7.3 64位 系统，所以对于其他系统不做讲解，毕竟没有躬身，以免误导大家。</p>\n</blockquote>\n<h2>一、安装 node</h2>\n<p>我的个人项目后端部分均基于 node 开发， 所以服务器安装 node 就无可避免了。其实 node 的安装非常简单便捷，根据官方文档，在 Centos 系统安装 node 只需要三步。</p>\n<ol>\n<li>设置repository源：</li>\n</ol>\n<pre class=\"prettyprint\"><code>curl --silent --location https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_8.x | sudo bash -\n</code></pre><p>如果你要安装 Node.js 9:</p>\n<pre class=\"prettyprint\"><code>curl --silent --location https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_9.x | sudo bash -\n</code></pre><p>2、安装 nodejs</p>\n<pre class=\"prettyprint\"><code>sudo yum -y install nodejs\n</code></pre><p>3、安装构建工具（可选）\n要从 npm 编译和安装本地插件，你还需要安装构建工具：</p>\n<pre class=\"prettyprint\"><code>sudo yum install gcc-c++ make\n</code></pre><p>此处遇到的问题：\n我在安装的过程中先配置了 nodejs 6 的 repository源：</p>\n<pre class=\"prettyprint\"><code>curl --silent --location https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_6.x | sudo bash -\n</code></pre><p>后来在配置 nodejs 8 , 却一直安装 nodejs 6. 后来找到解决方案，需要先清除 repository源，然后重新配置：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;如果设置多个源，默认会一直按照第一源安装，所以需要运行以下命令清除源，\nsudo rm -fv &#x2F;etc&#x2F;yum.repos.d&#x2F;nodesource*\n重新设置：\ncurl --silent --location https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_8.x | sudo bash -\nsudo yum install nodejs\n</code></pre><p>附上node官方安装文档： <a href=\"https://nodejs.org/en/download/package-manager/\">Installing Node.js via package manager</a></p>\n<h2>二、安装 mongo</h2>\n<p>mongo 官方的安装文档其实也是非常友好，按照文档步骤一步一步进行即可，服务启动过程中可能会遇到坑，下文将会介绍：</p>\n<ol>\n<li>配置包管理系统（yum）\n安装最新版 MongoDB 3.6 , 创建一个 mongo 的包管理文件 <code>/etc/yum.repos.d/mongodb-org-3.6.repo</code>，然后在文件中写入以下配置：</li>\n</ol>\n<pre class=\"prettyprint\"><code>[mongodb-org-3.6]\nname=MongoDB Repository\nbaseurl=https:&#x2F;&#x2F;repo.mongodb.org&#x2F;yum&#x2F;redhat&#x2F;$releasever&#x2F;mongodb-org&#x2F;3.6&#x2F;x86_64&#x2F;\ngpgcheck=1\nenabled=1\ngpgkey=https:&#x2F;&#x2F;www.mongodb.org&#x2F;static&#x2F;pgp&#x2F;server-3.6.asc\n</code></pre><p>如果要安装 3.4 版本，就 创建一个  3.4 的管理文件 <code>/etc/yum.repos.d/mongodb-org-3.4.repo</code> ，然后写入：</p>\n<pre class=\"prettyprint\"><code>[mongodb-org-3.4]\nname=MongoDB 3.4 Repository\nbaseurl=https:&#x2F;&#x2F;repo.mongodb.org&#x2F;yum&#x2F;redhat&#x2F;$releasever&#x2F;mongodb-org&#x2F;3.4&#x2F;x86_64&#x2F;\ngpgcheck=0\nenabled=1\n</code></pre><p>2、安装 MongoDB 包</p>\n<pre class=\"prettyprint\"><code>sudo yum install -y mongodb-org\n</code></pre><p>3、启动 MongoDB 服务</p>\n<pre class=\"prettyprint\"><code>sudo service mongod start\n</code></pre><p>简单 3 步即可完成 mongo 的安装和服务的启动\n4、停止 MongoDB 服务</p>\n<pre class=\"prettyprint\"><code>sudo service mongod stop\n</code></pre><p>5、重启 MongoDB 服务</p>\n<pre class=\"prettyprint\"><code>sudo service mongod restart\n</code></pre><p><code>/var/log/mongodb/mongod.log</code> 文件为 MongoDB 默认的log文件，可以查看服务启动过程中的所有日志。\n6、使用 MongoDB\n···\nmongo --host 127.0.0.1:27017\n···\n通过该命令即可在主机上运行一个 mongo shell\nmongo 默认是没有权限验证的，也就是说任何人都可以轻易的连接你服务器上的 mongo 并对数据进行操作。\n所以需要修改 Mongo 的配置文件，打开权限验证，增加数据库权限，也可以修改 绑定的主机ip、 端口号（默认为：27017）。配置文件修改如下：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;设置日志文件\nsystemLog:\n  destination: file\n  logAppend: true\n  path: &#x2F;var&#x2F;log&#x2F;mongodb&#x2F;mongod.log\n\n&#x2F;&#x2F;设置数据存储目录\nstorage:\n  dbPath: &#x2F;var&#x2F;lib&#x2F;mongo\n  journal:\n    enabled: true\n&#x2F;&#x2F;设置服务以后台进行的模式运行\nprocessManagement:\n  fork: true  # fork and run in background\n  pidFilePath: &#x2F;var&#x2F;run&#x2F;mongodb&#x2F;mongod.pid  # location of pidfile\n\n&#x2F;&#x2F;设置网络连接\nnet:\n  port: 27017           #默认端口，可以进行修改，例如 28018\n  bindIp: 127.0.0.1   # 设置绑定ip，只绑定本机\n\n\nsecurity:\n  authorization: enabled     # 开启权限验证，设置完成需要重启 mongo 服务\n</code></pre><p>关于如何设置 数据库权限可以参考我的博客文章：<a href=\"https://blog.yvanwang.com/blog/583ecd6c31d94535842bc18c\">mongodb数据库增加管理用户权限</a>\n在 mongo 服务启动的过程中如果遇到错误：</p>\n<pre class=\"prettyprint\"><code>Starting mongod (via systemctl):  Job for mongod.service failed because the control process exited with error code. \nSee &quot;systemctl status mongod.service&quot; and &quot;journalctl -xe&quot; for details.\n                                                           [FAILED]\n</code></pre><p>可以参考我的博客文章：<a href=\"https://blog.yvanwang.com/blog/5a1d6b0153503b4959e05276\">Mongo 服务启动踩坑记</a></p>\n<h2>安装 nginx</h2>\n<p>我之前的服务部署时是使用的 <code>http-proxy</code> 配置的服务代理转发，后来转用了nginx，主要是学习了解一下基本的nginx配置，nginx 的安装也很简单方便：\n1、增加nginx源：</p>\n<pre class=\"prettyprint\"><code>sudo yum install epel-release\n</code></pre><p>2、安装 nginx</p>\n<pre class=\"prettyprint\"><code>sudo yum install nginx\n</code></pre><p>3、启动nginx</p>\n<pre class=\"prettyprint\"><code>sudo systemctl start nginx\n</code></pre><p>现在可以访问 <code>http://your_ip</code> 来判断你服务器上的nginx是否启动成功，如果看到：\n<img src=\"//dn-cnode.qbox.me/FnQjNybEY_uyRQDFUkA8iv70Tokb\" alt=\"nginx_default.png\">\n恭喜你，现在你的 整套环境配置就已经完成了。\n整体来看，在 Centos 上安装 node、mongo、nginx 都是很简单的，\n无非就是 1、打开冰箱 2、把大象放进去 3、关上冰箱。 ~</p>\n<p>参考文献：\n<a href=\"https://nodejs.org/en/download/package-manager/#installing-node-js-via-package-manager\">Installing Node.js via package manager</a>\n<a href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\">Install MongoDB Community Edition on Red Hat Enterprise or CentOS Linux</a>\n<a href=\"https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7\">How To Install Nginx on CentOS 7</a></p>\n<p>文章来自我的个人博客： <a href=\"https://www.yvanwang.com/post/5a5c66924b22480021d85214\">https://www.yvanwang.com/post/5a5c66924b22480021d85214</a></p>\n</div>","title":"Centos 从安装到部署 之 node/mongo/nginx（一）","last_reply_at":"2018-01-20T12:38:50.706Z","good":false,"top":false,"reply_count":9,"visit_count":582,"create_at":"2018-01-15T03:21:29.006Z","author":{"loginname":"yvanwangl","avatar_url":"https://avatars2.githubusercontent.com/u/11405052?v=4&s=120"}},{"id":"5a6208cdafa0a121784a8dce","author_id":"54edd6faf08635a279d18cff","tab":"share","content":"<div class=\"markdown-text\"><h3>概述</h3>\n<p>传统的JSP页面应用无法有效的使用ES6语法特性，项目打包压缩困难，无法热更新。传统的单页应用在Tomcat等容器下无法进行服务端渲染到达SEO的效果。本项目工程很好融合的传统JSP页面服务端渲染的特点和单页应用开发特性且极易上手使用!</p>\n<h3>源码地址</h3>\n<p><a href=\"https://github.com/nqdy666/wjsp\">源码地址</a></p>\n<h3>Demos与文档</h3>\n<p><a href=\"http://wjsp.qjzd.net/\">Demos与文档</a></p>\n<h3>特性</h3>\n<ul>\n<li>多页应用</li>\n<li>JSP嵌套</li>\n<li>el表达式</li>\n<li>服务端渲染(SEO)</li>\n<li>热部署</li>\n<li>js,css语法转换</li>\n<li>eslint</li>\n<li>热更新</li>\n<li>支持Vue</li>\n<li>打包压缩</li>\n<li>IE9+\n支持传统JSP开发所的所有功能；可以通过自定义webpack配置来实现对react的支持；通过引入vue-router和vuex某一个页面完成可以变成一个单页应用。</li>\n</ul>\n<p>如果您想要支持IE8，那需要把webpack降级，因为webpack2+是不支持IE8的，以及尽量避免去使用不支持IE8的库，比如jquery2+，lodash4+, Vue等，祝您好运。</p>\n<h3>环境搭建</h3>\n<p>工欲善其事，必先利其器。</p>\n<ul>\n<li>JDK1.7+</li>\n<li>IntelliJ IDEA，需要安装js相关插件和配置支持es6语法。</li>\n<li>Maven3+</li>\n<li>Tomcat7+，端口默认请使用8080</li>\n<li>Git bash</li>\n<li>npm3+</li>\n<li>node7+</li>\n</ul>\n<p>如果您喜欢编辑js和css的时候用vscode也是没有问题，不过编写jsp和java还是推荐用idea。</p>\n<p>以下总结环境配置的相关文章，可供参考\n<a href=\"https://qjzd.net/topic/5a4e1ef4f918faeb40031460\">JDK下载地址</a>\n<a href=\"https://qjzd.net/topic/5a4ee74ff918faeb40031461\">IntelliJ IDEA配置前端开发环境</a>\n<a href=\"https://qjzd.net/topic/5a4eef92f918faeb40031462\">IntelliJ IDEA配置JAVA WEB的Tomcat环境</a>\n<a href=\"https://qjzd.net/topic/5a4ef4f0f918faeb40031463\">maven下载安装</a>\n<a href=\"https://qjzd.net/topic/5a4ef698f918faeb40031464\">Git Bash下载安装</a></p>\n<h3>目录说明</h3>\n<pre class=\"prettyprint\"><code>├── pom.xml   &#x2F;&#x2F; maven配置文件\n├── src\n|  ├── main\n|  |  ├── filters\n|  |  |  └── resources &#x2F;&#x2F; java工程资源配置目录\n|  |  ├── java &#x2F;&#x2F; java代码目录\n|  |  ├── js &#x2F;&#x2F; 前端页面工程\n|  |  |  ├── build  &#x2F;&#x2F; 编译相关以及webpack相关配置\n|  |  |  |  ├── build.js\n|  |  |  |  ├── check-versions.js\n|  |  |  |  ├── logo.png\n|  |  |  |  ├── utils.js\n|  |  |  |  ├── webpack.base.conf.js\n|  |  |  |  ├── webpack.dev.conf.js\n|  |  |  |  └── webpack.prod.conf.js\n|  |  |  ├── config &#x2F;&#x2F; 配置相关\n|  |  |  |  ├── dev.env.js\n|  |  |  |  ├── index.js\n|  |  |  |  ├── js-jsp-map.js &#x2F;&#x2F; 配置入口js和jsp的映射\n|  |  |  |  └── prod.env.js\n|  |  |  ├── package.json &#x2F;&#x2F; npm配置\n|  |  |  ├── src &#x2F;&#x2F; web项目工程目录\n|  |  |  |  ├── pages &#x2F;&#x2F; jsp页面，最终的jsp文件们会按照pages相对路径打包进webapp&#x2F;WEB-INF&#x2F;jsp目录下\n|  |  |  |  |  ├── include &#x2F;&#x2F; 共享的jsp页面，通过jsp:include引入\n|  |  |  |  |  |  ├── common_script.jsp\n|  |  |  |  |  |  ├── footer.jsp\n|  |  |  |  |  |  ├── header.jsp\n|  |  |  |  |  |  ├── init.jsp\n|  |  |  |  |  |  └── meta.jsp\n|  |  |  |  |  ├── index &#x2F;&#x2F; 页面1\n|  |  |  |  |  |  ├── index.js &#x2F;&#x2F; 需要在在config&#x2F;js-jsp-map.js配置与jsp的映射关系，这样编译后的js会加载jsp的body下。一般js与jsp在同一个目录下。\n|  |  |  |  |  |  └── index.jsp\n|  |  |  |  |  └── start &#x2F;&#x2F; 页面2\n|  |  |  |  |     ├── dashboard.css\n|  |  |  |  |     ├── index.js\n|  |  |  |  |     └── index.jsp\n|  |  |     |     └── my-component.vue 支持VUE\n|  |  |     ├── polyfills 兼容相关的代码\n|  |  |     |  ├── console.js\n|  |  |     |  ├── index.js\n|  |  |     |  └── promise.js\n|  |  |     ├── static &#x2F;&#x2F; 存在静态文件，最终这些文件会拷贝到webapp目录下\n|  |  |     |  ├── favicon.ico\n|  |  |     |  ├── images\n|  |  |     |  |  ├── jsp.svg\n|  |  |     |  |  └── webpack.svg\n|  |  |     |  ├── js\n|  |  |     |  |  └── lib\n|  |  |     |  |     └── jquery.min.js\n|  |  |     |  └── WEB-INF\n|  |  |     |     ├── tld\n|  |  |     |     └── web.xml\n|  |  |     └── styles\n|  |  └── webapp &#x2F;&#x2F; 该目录下的文件不用开发人员手动添加修改，在npm run dev或npm run build的时候自动生成。\n|  └── test\n|     └── java\n</code></pre><p>src/main/js目录下的目录结构是在vue-cli的webpack模板的基础上修改的，如果您使用过该模板创建过项目，那么将很容易会上手。</p>\n<h3>开发</h3>\n<p><code>cd src/main/js</code>\n<code>npm run dev</code></p>\n<p>在idea中启动tomcat</p>\n<p>在浏览器中打开<code>http://localhost:8081</code></p>\n<p>以下几点需要注意一下</p>\n<p>首次启动项目，建议先<code>npm run dev</code>在启动tomcat。之后其中一个重启，另外一个可以不用重启。\n默认情况下<code>npm run dev</code>跑在8081端口下，tomcat跑在8080端口下。最终在浏览器访问只需要访问8081的页面，8080页面没有必要。\n开发模式下，js引入的css是动态引入的，页面会出现闪变的效果。不用担心，在发布后的环境中是不会出现的。\n开发jsp页面的时候，热部署会有延时，具体参看JSP页面这一章节\n开发jsp文件务必在pages目录下开发，切勿在webapp目录下开发。否则在切换到pages目录下开发或者打包后或，webapp下的jsp的文件会被覆盖，导致修改的内容丢失。</p>\n<h3>打包发布</h3>\n<p><code>npm run build</code></p>\n<p>webapp作为输出目录，static中文件会拷贝到输出目录，pages目录下的jsp文件会作为模板文件拷贝到webapp/WEB-INF/jsp目录下，与jsp关联的js入口会被合并压缩后引入到jsp文件的body中。jsp关联的css会被抽离出一个单个的css文件引入的jsp文件head中。</p>\n<p>如果您打包后的应用的Application Context不是/, 比如是<code>/app</code>，即访问地址都是基于<code>http://localhost:8080/app</code>，那么打包的时候webpack的<code>publicPath</code>参数记得配置/app，且jsp页面中所有的地址都需要带上<code>${pageContext.request.contextPath}/</code>，在该项目框架中可以简写为<code>${ctx}/</code></p>\n<h3>JSP页面</h3>\n<p>传统的JSP是在<code>src/main/webapp</code>下开发，在这个项目框架下开发jsp文件是在<code>src/main/js/src/pages</code>下开发。虽然开发目录不一致，但依然拥有传统jsp开发所有的特性。</p>\n<ul>\n<li>模板嵌套，比如使用<code>&lt;jsp:include page=''&gt;&lt;/jsp:include&gt;</code>或者<code>&lt;%@include file=&quot;&quot;%&gt;</code></li>\n<li>el表达式，<code>&lt;c:set&gt;</code>, <code>&lt;c:if&gt;</code>, <code>&lt;c:forEach&gt;</code>等都可以使用</li>\n<li>嵌入Java代码 比如使用<code>&lt;% out.println(&quot;hello world&quot;); %&gt;</code></li>\n<li>支持热部署。配置好启动tomcat相关参数。在修改完jsp保存文件后，约10秒后刷新页面就可以看到页面的变化。如果等不及10秒或者页面一直不刷新，可以先点击idea菜单<code>File-&gt;Syncronize&gt;</code>同步文件（快捷键<code>Ctrl+Alt+Y</code>），然后在点击Run的左侧第三个按钮后选择<code>Update classes and resources</code>手动更新，之后就刷新页面就可以看到最新出的页面。\n实际在<code>npm run dev</code>的时候，pages目录下的jsp会作为htmlWebpackPlugin插件的模板文件，每次修改pages下的文件都会被输出到<code>webapp/WEB-INF/jsp</code>下的相对目录。需要了解具体原理，请前往核心章节</li>\n</ul>\n<h3>自定义标签库</h3>\n<p>除了标准的c, fmt, fn标签库外，您也可以自定义标签库。</p>\n<ul>\n<li>首先在static/WEB-INF/tld新建一个tld，比如elftld</li>\n<li>然后jsp页面引入，<code>&lt;%@ taglib prefix=&quot;elf&quot; uri=&quot;/WEB-INF/tld/elfunc.tld&quot; %&gt;</code></li>\n</ul>\n<p>注意的是，在jsp页面的地址必须以/WEB-INF/开头，而实际开发jsp的路径是在<code>js/src/pages</code>目录下，导致idea无法正常解析pages目录下jsp中tld文件路径，在使用自定义标签的时候也无法自动补全。不过可以正常运行，实际开发过程影响不大。如果您有更好的解决方案，请与我们联系。</p>\n<h3>语法转换</h3>\n<p>因为了使用了webpack作为打包工具，您可以轻松对js和css进行语法转换，目前支持：</p>\n<ul>\n<li>es6, stage-2</li>\n<li>postcss</li>\n<li>less, sass, scss 需要额外装对应的loader即可支持</li>\n</ul>\n<h3>热更新</h3>\n<p>在开发单页应用的过程中，有一个很棒的特性就是热更新，修改了js文件，页面实时就会触发更新。\n在此项目框架下，您依然可以享受到热更新带来的喜悦，在您修改js和css的时候，页面都会实时触发更新。</p>\n<h3>VUE</h3>\n<p>该项目已经默认支持Vue。这一章节也是用VUE编写的，你可以尽情的享受VUE带来的编码的快乐。</p>\n<ul>\n<li>您可以给idea添加vue.js插件，这样也可以直接使用.vue文件。</li>\n<li>js和css的语法转换在.vue文件中同样适用。</li>\n</ul>\n<h3>核心</h3>\n<p>该项目融合了webpack和jsp两者的特性实现了多页应用，这很酷。那到底是如何实现的呢。这里我们从搭建项目遇到的问题来讲讲最核心的几个问题是如何解决的。</p>\n<h5>HtmlWebpackPlugin</h5>\n<p>使用webpack实现多页应用，很容易联想到配置多个entry入口，每一个entry对应一个<code>HtmlWebpackPlugin</code>。jsp文件作为<code>HtmlWebpackPlugin</code>的模板文件，在entry的js在打包之后会插入到body下。该项目也是按照这样的搭建的。\n这里有几点需要注意</p>\n<ul>\n<li>HtmlWebpackPlugin解析jsp文件需要对应的loader，需要在webpack中配置<code>{ test: /\\.jsp$/, loader: 'raw-loader' }</code>，这里使用<code>raw-loader</code>进行纯文本拷贝。如果您有更适合jsp的loader，那么您可以赋予jsp文件特多的特性。</li>\n<li>因为jsp可以被嵌套，这些被嵌套的jsp，并不是入口的jsp。所有只有是入口的jsp在配合HtmlWebpackPlugin插件的会额外添加{inject: ‘body’}参数</li>\n<li>那如何规定哪些jsp是入口文件呢？我们是通过配置来约定entry的js与jsp的关联关系，配置文件在<code>config/js-jsp-map.js</code>中。</li>\n</ul>\n<h3>proxy反代</h3>\n<p>tomcat是跑在8080端口下的，webpack-dev-server是跑在8081端口下的，是两个不同应用。那岂不是开发jsp要在tomcat下编写调试，开发js在webpack-dev-server调试。这样的话岂不是很麻烦。</p>\n<p>庆幸的webpack-dev-server有一个proxy参数，我们利用proxy把访问webpack-dev-server的请求都反代到8080下。这样实际开发过程中浏览器只要打开8081端口页面就可以。这样就做到兼顾jsp服务端渲染的功能，以及webpack语法转换，热更新的功能。tomcat只有在必要的时候重启一下就好。\n这里有几点需要注意</p>\n<ul>\n<li><code>npm run dev</code>和启动tomcat并没有顺序要求，不过在浏览器访问8081前需要把这两个服务都启动起来。</li>\n<li>当涉及到jsp文件有新增删除，或者static目录下的文件有新增编辑删除时，需要重新<code>npm run dev</code>和重启tomcat。记住一点，如果有文件新增和删除，最好都把这两个服务都重启一下肯定是没有问题的。</li>\n</ul>\n<h3>WriteFilePlugin</h3>\n<p>我们知道webpack-dev-server是使用内存中的文件系统。而jsp页面最终是要发布到tomcat的，内存中的jsp文件并不能被idea监听，这样即使最终输出的jsp发生改变也无法被deploy到tomcat。\n庆幸我们找到了一个webpack的插件WriteFilePlugin，它能强制把webpack-dev-server程序的输出的文件写到磁盘文件系统上。\n这里有几点需要注意</p>\n<ul>\n<li>虽然通过WriteFilePlugin的jsp文件输出到磁盘上了，但是因为不是通过idea直接修改，idea还是无法立刻同步这些文件。idea同步并发布jsp文件会有10s的延迟。如果等不及10秒或者页面一直不刷新，可以先点击idea菜单File-&gt;Syncronize&gt;同步文件（快捷键Ctrl+Alt+Y），然后在点击Run的左侧第三个按钮后选择Update classes and resources手动更新，之后就刷新页面就可以看到最新出的页面。</li>\n</ul>\n<h3>结语</h3>\n<p>这个思路其实不仅适用tomcat下的jsp多页应用，同样也是适用node作为服务器的多页应用。Enjoy it!</p>\n</div>","title":"WEBPACK + JSP 构建多页应用","last_reply_at":"2018-01-20T12:13:04.931Z","good":false,"top":false,"reply_count":6,"visit_count":242,"create_at":"2018-01-19T15:03:41.763Z","author":{"loginname":"nqdy666","avatar_url":"https://avatars2.githubusercontent.com/u/5211893?v=4&s=120"}},{"id":"5a5730cea3692d014f4f13d3","author_id":"5a52dfb6a3692d014f4f12ba","tab":"share","content":"<div class=\"markdown-text\"><h4>acme.sh能申请免费的ssl证书，并可以定期更新证书，非常省心 。</h4>\n<h4><a href=\"https://ssstk.tk\">SS翻墙梯子</a>速度快稳定享受科学上网</h4>\n<h1>1. 安装 <strong><a href=\"http://acme.sh\">acme.sh</a></strong></h1>\n<p>安装很简单, 一个命令:</p>\n<pre class=\"prettyprint language-  bash\"><code>\tcurl  https:&#x2F;&#x2F;get.acme.sh | sh\n</code></pre><p>普通用户和 root 用户都可以安装使用.建议root下执行\n安装过程进行了以下几步:</p>\n<ol>\n<li>把 <a href=\"http://acme.sh\">acme.sh</a> 安装到你的 <strong>home</strong> 目录下:</li>\n</ol>\n<pre class=\"prettyprint language- bash\"><code>\t~&#x2F;.acme.sh&#x2F;\n</code></pre><p>并创建 一个 bash 的 alias, 方便你的使用:  <code>acme.sh=~/.acme.sh/acme.sh</code></p>\n<h3>以下是在nginx上的使 步骤──</h3>\n<p>如果系统的80和443已经被其他虚拟主机运营占 ，则先做 个最普通的80端 的nginx 件</p>\n<pre class=\"prettyprint language-vim\"><code>   server {\n\t\tlisten       80;\n\t\tserver_name  example.com;\n\t\t\tlocation &#x2F; {\n\t\t\t\t\troot html;\n\t\t\t\t\tindex  index.html index.htm;\n\t\t\t}\n\t\tlocation = &#x2F;favicon.ico {\n\t\t\t\t\tlog_not_found off;\n\t\t\t\t\taccess_log off;\n\t\t\t}\n\t\terror_page   500 502 503 504  &#x2F;50x.html;\n\t\tlocation = &#x2F;50x.html {\n\t\t  root html;\n\t   }\n  }\n</code></pre><h4>检查配置 件语法错误</h4>\n<pre class=\"prettyprint language-bash\"><code>\tnginx -t\n</code></pre><h4>重启nginx让虚拟主机 效</h4>\n<pre class=\"prettyprint language-js\"><code>\tsystemctl restart nginx\n</code></pre><h4>动申请证书，acme.sh会检查nginx对此域名的http header是不是200,通过后把证书复制到 临时 录。</h4>\n<pre class=\"prettyprint language- bash\"><code>acme.sh --issue --nginx -d example.com --debug\n</code></pre><h4>将证书从临时 录部署到nginx/ssl下，但不会修改现有的conf 件</h4>\n<pre class=\"prettyprint language-bash\"><code>   \tacme.sh --install-cert -d example.com \\\n \t--key-file &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;example.com&#x2F;key.pem  \\\n  \t--fullchain-file &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;example.com&#x2F;cert.pem \\\n  \t--reloadcmd &quot;service nginx force-reload&quot;\n</code></pre><h4>复制 个现成的带ssl配置的conf替换掉80端 的配置 件</h4>\n<pre class=\"prettyprint language-bash\"><code> server {\n   listen         80;\n   server_name    www.ssstk.tk ssstk.tk;\n   rewrite        ^   https:&#x2F;&#x2F;$server_name$request_uri? permanent;\n }\n server {  \n   listen                 443 ssl http2;\n   server_name            www.ssstk.tk ssstk.tk;\n   ssl                    on;\n\n   ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;ssstk.tk&#x2F;cert.pem;\n   ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;ssstk.tk&#x2F;key.pem;\n\n   charset utf-8;\n\n   access_log  &#x2F;opt&#x2F;logs&#x2F;nginx&#x2F;ssstk.access.log;\n   error_log   &#x2F;opt&#x2F;logs&#x2F;nginx&#x2F;ssstk.error.log;\n\n   location &#x2F; {\n       proxy_set_header   X-Real-IP $remote_addr;\n       proxy_set_header   Host      $http_host;\n       proxy_pass         http:&#x2F;&#x2F;127.0.0.1:8000;\n   }\n }\n</code></pre><p>分享下使用acme.sh搭建的站点</p>\n</div>","title":"分享申请免费的ssl证书    【科学上网】方法","last_reply_at":"2018-01-20T12:09:08.414Z","good":false,"top":false,"reply_count":6,"visit_count":864,"create_at":"2018-01-11T09:39:26.802Z","author":{"loginname":"ssstk","avatar_url":"https://avatars1.githubusercontent.com/u/35208138?v=4&s=120"}},{"id":"5a6329289d371d4a059eec91","author_id":"5913f3b43504ce1c2ac45ac2","tab":"ask","content":"<div class=\"markdown-text\"><p>jasmine 可以dubug吗，如何debug</p>\n</div>","title":"jasmine 可以dubug吗，如何debug","last_reply_at":"2018-01-20T11:34:00.732Z","good":false,"top":false,"reply_count":0,"visit_count":104,"create_at":"2018-01-20T11:34:00.732Z","author":{"loginname":"majinliang123","avatar_url":"https://avatars1.githubusercontent.com/u/15165848?v=4&s=120"}},{"id":"5a41e5e7d1536726354b8140","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><p>Live 简介\n你好，我是 i5ting ，江湖人称「狼叔」，目前是阿里巴巴技术专家，斯达克学院（ StuQ ）明星讲师， Node.js 技术布道者。曾就职于去哪儿、新浪、网秦，做过前端、后端、数据分析，是一名全栈技术的实践者。</p>\n<p>现在，越来越多的科技公司和开发者开始使用 Node.js 开发各种应用。Node.js除了能够辅助大前端开发外，还可以编写Web应用，封装Api，组装RPC服务等，甚至是开发VSCode编辑器一样的PC客户端。和其它技术相比， Node.js 简单易学，性能好、部署容易，能够轻松处理高并发场景下的大量服务器请求。Node.js 周边的生态也非常强大，NPM（Node包管理）上有超过60万个模块，日下超过载量3亿次。但编写 Node.js 代码对新人和其它语言背景的开发者来说，不是一件容易的事，在入门之前需要弄懂不少复杂的概念。</p>\n<p>我身边也有很多人问我：如何学习 Node.js ？作为一名 Node.js 布道者，我做过很多 Node.js 普及和推广的工作，对它的基本概念和核心模块都很熟悉； 此外，我还在撰写一本名为《更了不起的 Node.js 》的书，已经写了 2 年，积累了很丰富的资料，本次 Live 也将为你提供对 Node.js 更全面的解读。</p>\n<p>本次 Live 主要包括以下内容</p>\n<ol>\n<li>前言：学习 Node.js 的三个境界</li>\n<li>准备：\n<ul>\n<li>Node 用途那么多，我该从哪里学起？</li>\n<li>Node Web 框架那么多，我该怎么选？</li>\n<li>关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n</li>\n<li>延伸：大前端变化那么快，如何才能做到每日精进？</li>\n<li>实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</li>\n<li>答疑：回答大家的问题</li>\n</ol>\n<p>本次Live主要是科普，适用新用户和比较迷茫的Node朋友，参加地址</p>\n<p><a href=\"https://www.zhihu.com/lives/928687583372926976\">https://www.zhihu.com/lives/928687583372926976</a></p>\n<p><img src=\"//dn-cnode.qbox.me/FocRNMua7wr-LraAm-6oJ7qgQgGL\" alt=\"屏幕快照 2018-01-21 下午7.00.53.png\"></p>\n<p><img src=\"//dn-cnode.qbox.me/FvKECr-VJpG8UVqoHni_7rUq6W0_\" alt=\"屏幕快照 2018-01-21 下午7.00.39.png\"></p>\n<p><img src=\"//dn-cnode.qbox.me/Fm1o3JD5u9Z1-VqL6zbpxCYaG9-O\" alt=\"屏幕快照 2018-01-21 下午7.00.25.png\"></p>\n<p><img src=\"//dn-cnode.qbox.me/FgQkotnlgs7UB2uUIX66EWio0gSS\" alt=\"屏幕快照 2018-01-21 下午7.00.11.png\"></p>\n<p><img src=\"//dn-cnode.qbox.me/FrLJxqF0zjLcFnq1ONqrtL1G_OnK\" alt=\"屏幕快照 2018-01-21 下午6.59.56.png\"></p>\n<p><img src=\"//dn-cnode.qbox.me/Fr5i3vsVCYcCSiXP3-8_uxkZzaZz\" alt=\"屏幕快照 2018-01-21 下午6.59.36.png\">\n<img src=\"//dn-cnode.qbox.me/Fj4c-NU7tf3U_yRVWmBlEzVALxhZ\" alt=\"屏幕快照 2018-01-21 下午6.59.19.png\"></p>\n<p><img src=\"//dn-cnode.qbox.me/Fs0qlU63hKM2AKEzufgwrY4PzpZC\" alt=\"屏幕快照 2018-01-21 下午6.59.00.png\"></p>\n<p><img src=\"//dn-cnode.qbox.me/Flep-W9e2bqoGPu10aR5nsQOM2WZ\" alt=\"屏幕快照 2018-01-21 下午6.58.46.png\"></p>\n</div>","title":"【知乎Live】狼叔：如何正确的学习Node.js","last_reply_at":"2018-01-20T10:44:07.721Z","good":false,"top":false,"reply_count":17,"visit_count":2611,"create_at":"2017-12-26T06:02:15.095Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"5a630ae4afa0a121784a8df2","author_id":"5a5ec12a9288dc8153287eb9","tab":"ask","content":"<div class=\"markdown-text\"><p>举例：\n\t前提：系统有三方   1. 运营方、2. 店铺（B端用户）3. 用户（C端用户）  用户进行下单操作\n\t接口定义：\n\t\t查询订单详情接口：\n\t\t\tTo B:  /sellers/:sellerId/orders/:orderId\n\t\t\tTo C:  /buyers/:buyerId/orders/:orderId\n问题：\n\t对于订单的这样的实体好解释，订单可以是用户的也可以是属于店铺的。如果只有运营平台和买方，运营平台查询一个商品信息可以是/items/:itemId，用户查看也是/items/:itemId。查询出来的信息，应该是运营平台要多一些，类似商品的销售提成这样的信息。如何定义RESTful路由？</p>\n</div>","title":"RESTful接口定义 对于相同实体的查询接口 后台管理员和用户的接口分别如何定义？","last_reply_at":"2018-01-20T10:13:07.412Z","good":false,"top":false,"reply_count":1,"visit_count":149,"create_at":"2018-01-20T09:24:52.033Z","author":{"loginname":"guo-q","avatar_url":"https://avatars1.githubusercontent.com/u/31874238?v=4&s=120"}},{"id":"5a630c649288dc8153287fe4","author_id":"56ce68bc842c03521a73520e","tab":"ask","content":"<div class=\"markdown-text\"><p>查询要求如下：</p>\n<ol>\n<li>搜索标签字段（数组类型，形如tag:[“好看”,“大气”,“高个子”]），如果用户输入了搜索条件就按条件搜索，如果没输入就搜索返回所有数据</li>\n<li>不准用$OR（这里简化了真实场景，真实场景中无法用$or）</li>\n<li>数据库中用户名字段，存在空值</li>\n</ol>\n</div>","title":"请教一条mongodb查询语句","last_reply_at":"2018-01-20T09:31:16.384Z","good":false,"top":false,"reply_count":0,"visit_count":123,"create_at":"2018-01-20T09:31:16.384Z","author":{"loginname":"qujinxiong","avatar_url":"https://avatars1.githubusercontent.com/u/15104950?v=4&s=120"}},{"id":"5a62ecca9288dc8153287fcd","author_id":"5a607b3d9288dc8153287f54","tab":"ask","content":"<div class=\"markdown-text\"><p>在用到pre(‘findOneAndUpdate’,function(next) {…})时，从回调的this里面获取到的字段是undefined，如果schema定义了字段meta，然后在执行findOneAndUpdate操作后，pre操作中回调获取this.meta是undefined，目前对mongoose还不太熟，不知从何分析</p>\n</div>","title":"mongoose中间件使用时的疑惑","last_reply_at":"2018-01-20T07:32:28.158Z","good":false,"top":false,"reply_count":2,"visit_count":100,"create_at":"2018-01-20T07:16:26.156Z","author":{"loginname":"Choicelin","avatar_url":"https://avatars0.githubusercontent.com/u/10152588?v=4&s=120"}},{"id":"5a61e5d8afa0a121784a8dc4","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><h1>我的2017年总结</h1>\n<p>在知乎上，我回复了《coding到没脾气的时候，你一般都会干什么？》<a href=\"https://www.zhihu.com/question/264015952/answer/278283535\">https://www.zhihu.com/question/264015952/answer/278283535</a> 这个问题。答案如下</p>\n<p>“【不扯淡】年轻时死磕，年长点让小弟死磕，现在抓个专家一起吃饭，没有什么是一顿饭解决不了的，不行就二顿</p>\n<p>工程师的能力不是编码和死磕，而是解决问题</p>\n<p>很多人点赞，就说的再明白点</p>\n<ul>\n<li>年轻死磕是为了长本事，30岁以前都可以这样做</li>\n<li>带团队后，要懂得任务下放，让更多人帮你，别带人越多越累</li>\n<li>30岁之后是打牌阶段，技能积累足够用，这时要注重社交，打组合拳才能玩的更好</li>\n</ul>\n<p>少抱怨，多思考，未来更美好</p>\n<p>强调30岁不是我创造的，大部分人都会认为30岁后事情，压力会明显大得多，比如家庭，孩子，房子，车子，票子，甚至是管理，权利，欲望等等吧。我感受最深的是身体不如从前和记忆力明显下降。”</p>\n<p>这其实是我这1年一个非常大的变化。想明白了很多事，心态上好了很多。另外，作为网红的好处的是你能够接触到<strong>更多信息和更好的朋友圈子</strong>。这其实是以前没法做到的。我本身也是偏于内向的人，只是不得已做公众号，演讲，布道，应酬，收获当然也是相当丰富的。以前看事情是<strong>点</strong>，现在看的是<strong>趋势</strong>，能够做到心中有数，自然胸有成竹的感觉。</p>\n<blockquote>\n<p>淡然，自省，大概是个比较好的状态。</p>\n</blockquote>\n<p>2017年年初儿子出生，银川没有合适工作，不得已，去了去哪儿工作，这也是个艰难的选择。之后去了得到，现在在阿里巴巴，关于工作的个中曲折后面会讲。在qunar的时候比较闲，跟着莫子（付洪波）老师练了半年多的形意拳，后来被方圆和timyang等老司机影响，也开始学习摄影。其实书法，诗歌，摄影类的艺术来说是有共性的，希望自己能够坚持下去。</p>\n<p>在个人品牌方面，这1年时间做了很多场500+人得演讲，写了很多精华文章，单篇最高超过9万阅读量。Node全栈公众号超过1.8万粉丝，我的个人知乎半年时间粉丝超过2200人（之前没玩过，感谢justjavac大神带路），组织了几次活动，也算是不错的尝试，可以接触到更多的Node.js相关的高手和各种需求，解决方案，对我的知识面是有很大提升的。另外，从qunar到阿里巴巴大厂摸爬滚打，也是学到很多东西，大厂是有很多有内涵的东西的，当然这要靠自己挖掘。同时，建立了个人网站 <a href=\"http://i5ting.com\">i5ting.com</a>，目前东西还比较少，但至少起步了。</p>\n<p>在2017年，完成了2本书：《更了不起的Node.js》和个人诗集《春天的恐惧症》。更了不起的Node.js拖了2年了，从Node 4写到node9了，过程是痛苦极了的，其实这2年对我的成长也是极大的，大部分时间都是在构建我个人的知识体系。本书“了不起”就是个很难讲的，要讲清楚“更了不起”就是件更难的事儿！好在node在最近2年应用场景等方面有了更广更好的应用，自身知识体系加上qunar和阿里巴巴的经验，能完成也是不容易的，换工作也是有好处的。目前2本书都交给编辑了，应该很快可以面世了。</p>\n<p>儿子已经一岁了，我媳妇把孩子照顾的非常好，健康，活泼可爱。这一年，我往返北京和银川太多次了。以前在quanr的时候，我没有租房，几乎每周末都回家。宝宝还没出生，我就到北京上班了，在qunar工作的那段时间里，我是最嚣张的，请了好多假。每周五晚上回银川，周日晚上回北京，卧铺车厢无情的空调，吹得我中风几次。可是，还是要回家。老婆孩子都在地方，才是家。最难过的是周一到周五，只能看媳妇通过微信发来宝宝的视频，一遍一遍的看，一遍一遍的想哭。</p>\n<pre class=\"prettyprint\"><code>媳妇发来宝宝的视频\n\n媳妇发来宝宝的视频\n只有九秒，一遍一遍的看\n宝宝二个月了\n已经会吃衣袖了\n\n媳妇发来宝宝的的视频\n只有九秒，既短又长\n已经有六天没有见到了\n愈加想念\n\n他不会说话，只会哭喊\n他不会动，虽然很想动\n他不乖，除了吃奶的时候\n他还不能陪爸爸一起玩\n\n媳妇发来宝宝的视频\n只有九秒，一遍一遍的看\n一路上，一遍一遍的看\n一遍一遍的想笑，想哭。。。\n\n“路人一定都觉得爸爸是个可爱的神经病”\n</code></pre><h2>关于工作</h2>\n<ul>\n<li>Qunar机票</li>\n<li>得到，呆了7周</li>\n<li>阿里巴巴大文娱</li>\n</ul>\n<p>很多人在网上黑我，说我换工作比较多。当然这是事实，但也要不至于如何如何吧。</p>\n<p>Qunar的管理和公司流程做的非常好，其内部被携程合并之后能做的事儿并不多。其实在qunar做的事儿是比较少得，大部分时间都在往返北京和银川的路上。在qunar，我做了3件事儿</p>\n<ul>\n<li>组织和饿了么北研的一次活动。活动大部分都是我和我朋友帮忙弄得，甘苦自知吧。从海报，文章，到演讲主题，到行程，每个细节都要自己做。后面被摘桃子也是正常。</li>\n<li>做了bigview，已开源，主要是bigpipe实现的框架。在qunar没太多存在感，所以也懒得去推。后面会持续投入，在Node.js做api中间件层，此框架是利器。</li>\n<li>促成了hiproxy的成长。代应（<a href=\"https://github.com/zdying%EF%BC%89%E6%98%AF%E9%9D%9E%E5%B8%B8%E4%B8%8D%E9%94%99%E7%9A%84%E5%B0%8F%E4%BC%99%E4%BC%B4%EF%BC%8C%E6%9C%89%E6%83%B3%E6%B3%95%E6%9C%89%E6%89%A7%E8%A1%8C%E5%8A%9B%EF%BC%8Cqunar%E5%86%85%E9%83%A8%E5%A4%A7%E9%87%8F%E4%BE%9D%E8%B5%96multi-hosts%E5%92%8Cnginx%EF%BC%8C%E5%88%87%E6%8D%A2%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%B2%9F%E9%80%9A%E6%88%90%E6%9C%AC%E9%9D%9E%E5%B8%B8%E5%A4%A7%EF%BC%8C%E4%BA%8E%E6%98%AF%E4%BF%83%E6%88%90%E4%BA%86%E4%BB%96%E4%BB%AC%E7%9A%84%E8%9E%8D%E5%90%88%EF%BC%8C%E5%8D%B3%E4%BD%BF%E7%94%A8hiproxy%E5%8F%AF%E4%BB%A5%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3%E3%80%82\">https://github.com/zdying）是非常不错的小伙伴，有想法有执行力，qunar内部大量依赖multi-hosts和nginx，切换项目的沟通成本非常大，于是促成了他们的融合，即使用hiproxy可以完美解决。</a> <a href=\"https://github.com/hiproxy/hiproxy\">https://github.com/hiproxy/hiproxy</a></li>\n</ul>\n<p>从qunar离职后，我去了得到，罗胖的公司。知识付费领域做的相当好的品牌。最有希望的独角兽，我以为自己能够在里面做出点成绩，我对罗辑思维的评价</p>\n<ul>\n<li>品控做的确实好，所有产品公司里确实牛逼，打磨一个课程能够如此用心，真是难得。编辑工作做的也极好，对于错字，典故等也审核极其严格。</li>\n<li>产品细节做的也不错，快刀青衣对产品的把握感觉非常好，如果没想清楚，宁可不加，这在某种程度上，保证里app的简洁。</li>\n</ul>\n<p>但是一个快速增长的公司必然面临扩张期的阵痛，老的项目一堆，新招一堆高手也不会立马奏效。面临的都是两难选择，之前的东西不想碰，自己擅长的又用不上，真是很尴尬。之前我以首席架构师进去的，但没法在架构上做改进，很多东西不是一个人能搞定的。另外业务发展太快就导致管理跟不上，天天各种需求追的要命，还要兼顾团队建设，这事情哪能鱼和熊掌兼得呢。</p>\n<p>我对自己的定位是专注于Node.js技术，既然没法做更多Node.js相关的内容，不如就离开。</p>\n<p>我个人挺喜欢快刀的做事风格，也可怜他的处境。我也创过业，也激情过。我特别理解他的想法。他选了个好方向，罗胖和脱不花也确实是在各自领域做的不错，祝福吧。</p>\n<p>之后，我去了阿里巴巴大文娱，就是之前的老优酷，技术名声以前是不太好的。但好在被阿里收购1年多得时间，基本都改成阿里基因了。我进入的时间还好，老板也很信任，交给我很多我很有干劲的工作。比如h5播放器，之前很多人都没搞定，把一个极其传统的代码改成一个时髦的开发方式，使用babel，webpack，做了单元测试和端到端测试，采用模块化和面向对象，架构做的我觉得还不错。我能感觉到团队的变化，我很高兴的。当然，我对大家也是比较狠的，每天review代码到很晚，每个细节都会抠，每天回家都非常玩，大家其实状态还不错，解决了以前的困扰，在技术能力上也有提升，最重要的是有成就感，原来这样写代码，大家都可以的。这种带团队的过程对我来说也是非常有成就感的。当播放器成熟，内部稳定后，通过公司审批后，也会走开源之路，也希望给公司的技术影响力做一些贡献。</p>\n<p>我是降薪来的阿里，原因有三，一是有事可为，老板重用你给你机会，二是集团内部是open的，偏偏我知识面足够可以看出它们的好处，算是另一种补偿吧，三是对个人品牌是一个升级，狼叔的职业生涯到此已经足够了，进可攻退可守，也算另一种自由吧！</p>\n<p>钱多是个优势而已，还有氛围，文化，信仰</p>\n<ul>\n<li>牛人多</li>\n<li>业务需要</li>\n<li>成熟后有更多精力</li>\n<li>内部竞争，优胜劣汰</li>\n<li>财务相对自由，可以追求信仰了</li>\n</ul>\n<p>前几天还和 @苏千 聊，我和 @死月絲卡蕾特 相继入职阿里，还有cnode社区著名程序员也即将入职阿里，当时大家开玩笑说:</p>\n<blockquote>\n<p>“前端的终极归宿是阿里，不是在阿里，就是在去阿里的路上”</p>\n</blockquote>\n<p>另外要说的一点是pc和h5站在使用Node.js做api中间层，其最佳实践已成型，量也是极大的。以前前端玩得还是比较弱，如果能够缓存+控制页面数据，获得一个性能极大的提升也是极好的。2018年，争取拿这个做主题演讲上qcon或archsummit大会。</p>\n<p>每天忙得很开心，这就是我现在状态。其实，我的折腾还是在于想做些事情。如果你也想跟我一起做事，请将简历邮件给我 <a href=\"mailto:langshu.ssl@alibaba-inc.com\">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p>\n<h2>关于《更了不起的Node.js》一书</h2>\n<p>节选部分和目录，让大家先睹为快。</p>\n<p>Node.js 简介</p>\n<p>Node.js 诞生于 2009 年，由 Joyent 的员工  <a href=\"https://github.com/ry\">Ryan Dahl</a>  开发而成，之后 Joyent 公司一直扮演着 Node.js 孵化者的角色。由于诸多原因，Ryan 在2012年离开社区，随后在2015年由于 Node 贡献者对 es6 新特性集成问题的分歧，导致分裂出iojs，并由 iojs 发布1.0、2.0和3.0版本。由于 iojs 的分裂最终促成了2015年Node基金会的成立，并顺利发布了4.0版本。Node.js基金会的创始成员包括 Google、Joyent、IBM、Paypal、微软、Fidelity 和 Linux基金会，创始成员将共同掌管过去由 Joyent 一家企业掌控的 Node.js 开源项目。此后，Node.js基金会发展非常好，稳定的发布5、6、7、8等版本，截止发稿最新版本已经是8.6，长期支持版本是6.11。</p>\n<p>Node.js 不是一门语言也不是框架，它只是基于 Google V8 引擎的 JavaScript 运行时环境，同时结合 Libuv 扩展了 JavaScript 功能，使之支持 io、fs 等只有语言才有的特性，使得 JavaScript 能够同时具有 DOM 操作(浏览器)和 I/O、文件读写、操作数据库(服务器端)等能力，是目前最简单的全栈式语言。</p>\n<p>早在2007年，Jeff Atwood 就提出了著名的 <code>Atwood定律</code></p>\n<blockquote>\n<p>任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现</p>\n</blockquote>\n<p>目前 Node.js 在大部分领域都占有一席之地，尤其是 I/O 密集型的，比如 Web 开发，微服务，前端构建等。不少大型网站都是使用 Node.js 作为后台开发语言的，用的最多的就是使用Node.js做前端渲染和架构优化，比如 <a href=\"https://www.taobao.com/\">淘宝</a> 双十一、<a href=\"https://www.qunar.com/\">去哪儿网</a> 的 PC 端核心业务等。另外，有不少知名的前端库也是使用 Node.js 开发的，比如，<a href=\"https://github.com/webpack/webpack\">Webpack</a> 是一个强大的打包器，<a href=\"https://github.com/facebook/react\">React</a>/<a href=\"https://github.com/vuejs/vue\">Vue</a> 是成熟的前端组件化框架。</p>\n<p>Node.js通常被用来开发低延迟的网络应用，也就是那些需要在服务器端环境和前端实时收集和交换数据的应用（API、即时聊天、微服务）。阿里巴巴、腾讯、Qunar、百度、PayPal、道琼斯、沃尔玛和 LinkedIn 都采用了 Node.js 框架搭建应用。</p>\n<p>另外， Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。</p>\n<p>当然了，Node.js 也有一些缺点。Node.js 经常被人们吐槽的一点就是：回调太多难于控制（俗称回调地狱）和 CPU 密集任务处理的不是很好。但是，目前异步流程技术已经取得了非常不错的进步，从Callback、Promise 到 Async函数，可以轻松的满足所有开发需求。至于 CPU 密集任务处理并非不可解，方案有很多，比如通过系统底层语言 Rust 来扩展 Node.js，但这样会比较麻烦。笔者坚信在合适的场景使用合适的东西，尤其是在微服务架构下，一切都是服务，可以做到语言无关。如果大家想使 JavaScript 做 CPU 密集任务，推荐 Node.js 的兄弟项目 <a href=\"http://fibjs.org/\">fibjs</a>，基于纤程(fiber，可以简单理解为更轻量级的线程)，效率非常高，兼容npm，同时没有异步回调烦恼。</p>\n<p>关于本书</p>\n<p>本书是我学习和使用 Node.js 的总结。在学习和使用 Node.js 的过程中，我写了不少文章，并对一些文章进行了加工和完善，发表在<a href=\"https://cnodejs.org/\">cnode</a>论坛和Node全栈公众号(nodeonly)上。在2015年初，我在天津创业，位置在空港附近，为了招人不得不做一些科普、布道的工作。当时是被忽悠的，创始人都不拿工资(蠢，被坑死后才知道)，结婚后媳妇在银川，我手上没钱，又不好意思找媳妇要，所以和 StuQ 做了一点课程，效果还不错，后来就和 StuQ 结缘，做知乎 Live 等，霍老板钦定 StuQ 明星讲师。随着 Node.js 科普、布道的增加，我就萌生了写一本书的想法，希望能比较系统地总结相关知识，巩固自己的知识体系，而不是停留在『零散』的状态中。正好被博文视点的大编辑张春雨发现，于是就有了这本书。</p>\n<p>首先，我参考一些相关的书籍，作了一个基础的思维导图。接下来，就要开始写作了，这也是最艰难的一关。</p>\n<p>我没有按照从头到尾的顺序写，而是已有相对比较完善的知识点入手，比如Koa框架、异步流程控制等等。就这样，一点一点地写，实在不想写了，就先搁置一下，过两天继续写。整个过程持续了2年，和编辑开玩笑说：“开始写的时候是Node 4.0，交稿的时候Node已经8.0了”。</p>\n<p>我在写作的过程中，给自己提了一个要求：<strong>尽量深入浅出，条理清晰</strong>。至于是否达到了，希望读者们多多批评指正，并给我提意见和建议。</p>\n<p>目录</p>\n<ul>\n<li><a href>01 Node.js初识</a></li>\n<li><a href>02 安装与入门</a></li>\n<li><a href>03 更了不起的Node.js</a></li>\n<li><a href>04 更好的Node.js</a></li>\n<li><a href>05 Node.js是如何执行的</a></li>\n<li><a href>06 模块与核心</a></li>\n<li><a href>07 异步写法与流程控制</a></li>\n<li><a href>08 下一代Web框架Koa入门</a></li>\n<li><a href>09 Koa的核心扩展机制：中间件</a></li>\n<li><a href>10 HTTP协议必知必会</a></li>\n<li><a href>11 Koa练习</a></li>\n<li><a href>12 数据库入门</a></li>\n<li><a href>13 数据库进阶</a></li>\n<li><a href>14 视图模板</a></li>\n<li><a href>15 Koa项目实战</a></li>\n<li><a href>16 自己动手写NPM模块</a></li>\n<li><a href>17 Node.js企业级Web开发</a></li>\n<li><a href>18 构建具有Node.js特色的微服务</a></li>\n<li><a href>19 让Node.js跑的更稳</a></li>\n<li><a href>20 让Node.js跑的更快</a></li>\n</ul>\n<p>博文视点的美女编辑在苦逼的整理中，预计出版在3月之后，20章，800页+，定价预计在130+。</p>\n<h2>主题演讲</h2>\n<ul>\n<li>2018年1月6日 敏捷之旅2017天津站 <a href=\"http://www.hdb.com/party/r9n52.html\">http://www.hdb.com/party/r9n52.html</a></li>\n<li>2018年1月5日 AI时代的移动技术革新 <a href=\"https://www.bagevent.com/event/1004907?bag_track=vcr\">https://www.bagevent.com/event/1004907?bag_track=vcr</a></li>\n<li>2017年11月23日 GITC 2017全球互联网技术大会 北京站 <a href=\"https://www.huodongjia.com/event-1745105617.html\">https://www.huodongjia.com/event-1745105617.html</a></li>\n<li>2017年11月18 天津GDG DevFest 2017  <a href=\"https://www.meetup.com/GDG-Tianjin/events/244891749/\">https://www.meetup.com/GDG-Tianjin/events/244891749/</a></li>\n<li>imweb腾讯深圳，9月份 <a href=\"http://imweb.io/topic/5975bf1152e1c21811630619\">http://imweb.io/topic/5975bf1152e1c21811630619</a></li>\n<li>iweb峰会，北京国家会议中心 <a href=\"http://www.huodongxing.com/event/5393043891500\">http://www.huodongxing.com/event/5393043891500</a></li>\n<li>Oracle Code北京7 月 14 日 <a href=\"https://developer.oracle.com/code/beijing\">https://developer.oracle.com/code/beijing</a></li>\n<li>2017年06月24日 HTML5梦工场 &amp; 微软开发者沙龙第10期——北京——前端那些事儿 <a href=\"http://www.html5dw.com/event/4477\">http://www.html5dw.com/event/4477</a></li>\n<li>2017年05月20日 全球首届 Vue.js 开发者大会 <a href=\"https://segmentfault.com/e/1160000009118583\">https://segmentfault.com/e/1160000009118583</a></li>\n</ul>\n<h2>精华文章</h2>\n<p>年度文章《2017，我们来聊聊 Node.js》 <a href=\"https://cnodejs.org/topic/58eee565a92d341e48cfe7fc%EF%BC%8C%E6%AD%A4%E6%96%87%E6%88%AA%E6%AD%A2%E5%8F%91%E7%A8%BF%E5%B7%B2%E7%BB%8F%E5%8D%95%E7%AF%87%E8%B6%85%E8%BF%87\">https://cnodejs.org/topic/58eee565a92d341e48cfe7fc，此文截止发稿已经单篇超过</a> <strong>9万</strong> 阅读量。在qcon大会，被徐川主编选为推荐文章，答疑解惑，大局观还是相当不错的。另外《Node.js 2016 回顾以及2017展望》h ttps://cnodejs.org/topic/588a959b1dc8ff8739cbc66d 也是类似的精华文章。</p>\n<p>网友yanlele评价</p>\n<p>毕业开始就开始撸JS，因为以前java出身，始终放不下java，最近两个月才开始真正接触node，一直在想node真的有前景嘛？一直很困扰在下，在下所在的城市，几乎没有用node真正意义上做开发的公司。这篇文章我也是前几天才看到，反反复复看了很多遍，真的写的很好。希望node在未来的18年会越来越好。</p>\n<p>狼叔回复的《Node相比传统服务端技术栈好在哪里？》<a href=\"https://cnodejs.org/topic/5a328967d92f2f5b185ace96%EF%BC%8C%E5%9B%9E%E5%A4%8D%E4%B9%8B%E5%90%8E%E6%9F%90%E4%B8%AA%E5%96%B7%E5%AD%90%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E6%8D%AE%E8%AF%B4%E8%B4%BA%E8%80%81hax%E5%9C%A8%E9%98%85%E8%AF%BB%E6%AD%A4%E6%96%87%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A4%AA%E6%8A%95%E5%85%A5%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%9D%90%E8%BF%87%E7%AB%99%E4%BA%86%E3%80%82\">https://cnodejs.org/topic/5a328967d92f2f5b185ace96，回复之后某个喷子的文章，据说贺老hax在阅读此文，因为太投入，导致坐过站了。</a></p>\n<p>狼叔说：本来不想回复的，匿名的那哥们写的挺好的，虽然不懂他为什么要匿名。但看到某些回复，不得不说几句。乱解读，误人子弟的事，还是有必要澄清的，以免Node有无端被黑，相信这也是所有布道者都应该承担这种除魔卫道的责任。</p>\n<p>《请别拿“死”人做文章》<a href=\"https://cnodejs.org/topic/59daf46f2543cb3368b1627e%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E5%9B%A0%E4%B8%BANode.js%E4%B9%8B%E7%88%B6Ryan\">https://cnodejs.org/topic/59daf46f2543cb3368b1627e，主要是因为Node.js之父Ryan</a> Dahl在google使用go，导致某些人过度解读。故而回复，以正视听</p>\n<p>狼叔说：Node.js之父Ryan Dahl在2012年就离开社区的，我们必须要承认他作为创始人的伟大创举，但不能标签化，ryan不代表node，从他离开社区后，对于社区而言，他就“死”在曾经的丰功伟绩上，未来与他无关！</p>\n<p>《迷茫时学习Node.js最好的方法》<a href=\"https://cnodejs.org/topic/59c75a3dd7cbefc511964688%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%8F%8D%E5%93%8D%E8%BF%98%E4%B8%8D%E9%94%99%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%86%E9%83%A8%E5%88%86%E4%BA%BA%E7%9A%84%E8%BF%B7%E8%8C%AB%E3%80%82\">https://cnodejs.org/topic/59c75a3dd7cbefc511964688，这篇文章反响还不错，解决了部分人的迷茫。</a></p>\n<p>狼叔说：这是真事儿，在3w咖啡整理书稿，然后小弟梁过来了，聊聊他的现状，一副很不好的样子，在天津我曾带过他大半年，总不能不管，我给他的建议是：“每天看10个npm模块”</p>\n<p>对于学习Node.js迷茫的人来说，这是最好的方式，当你不知道如何做的时候，就要向前（钱）看，你要知道积累哪些技能对以后有好处。对于学习Node.js必经之路，一定是要掌握很多模块用法，并从中汲取技巧、思路、设计思想的。与其不知道学什么，为什么不每天积累几个技巧呢？</p>\n<p>《请叫我Node.js 8》兼发布说明，<a href=\"https://cnodejs.org/topic/592e377e855efbac2cf7a4dd%EF%BC%8CNode.js\">https://cnodejs.org/topic/592e377e855efbac2cf7a4dd，Node.js</a> 8的发布是里程碑事件，随后就发布了Koa 2.x正式版。</p>\n<pre class=\"prettyprint\"><code>为了避免和V8引擎的名字冲突，请叫我Node.js 8\n</code></pre><p>核心内容</p>\n<ul>\n<li>是下一个长期支持版本</li>\n<li>更新 V8 到 5.8版本: 核心变更TurboFan &amp; Ingnition（加了jit即时编译）</li>\n<li>更新 npm 到 5.0.0：宇宙最快+自带lock文件</li>\n<li>引入新的 c/c++ 扩展方式：N-API，解决addon的编译问题</li>\n<li>Async函数性能提升</li>\n<li>Async Hooks API支持</li>\n</ul>\n<p>《如果你来设计一个基于Webpack的前端开发工具》<a href=\"https://cnodejs.org/topic/591919d4ba8670562a40f106%EF%BC%8C%E5%AF%B9%E4%BA%8Ewebpack%E5%92%8C%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%BC%94%E8%AE%B2%EF%BC%8C%E8%87%AA%E4%BB%A5%E4%B8%BA%E6%98%AF%E5%BE%97%E6%84%8F%E4%B9%8B%E4%BD%9C%E3%80%82%E8%83%BD%E5%A4%9F%E7%9C%9F%E6%AD%A3%E4%BB%8E%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85%EF%BC%8C%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E5%8C%85%E8%BF%87%E7%A8%8B%E6%9D%A5%E5%88%86%E6%9E%90%E7%9A%84%EF%BC%8C%E7%9B%AE%E5%89%8D%E7%9C%8B%E5%8F%AA%E6%9C%89%E6%88%91%E4%B8%80%E4%B8%AA%E4%BA%BA%E3%80%82%E5%B8%AE%E7%8E%89%E6%B5%A9review%E4%BA%86%E3%80%8AWebpack\">https://cnodejs.org/topic/591919d4ba8670562a40f106，对于webpack和前端工程化演讲，自以为是得意之作。能够真正从如何打包，到浏览器解包过程来分析的，目前看只有我一个人。帮玉浩review了《Webpack</a> 前端工程化入门》<a href=\"http://gitbook.cn/gitchat/column/59e065f64f7fbe555e479204%E3%80%82%E8%BF%99%E7%AF%87%E5%85%A5%E9%97%A8%E4%B9%9F%E8%BF%98%E6%98%AF%E7%9B%B8%E5%BD%93%E4%B8%8D%E9%94%99%E7%9A%84%E3%80%82\">http://gitbook.cn/gitchat/column/59e065f64f7fbe555e479204。这篇入门也还是相当不错的。</a></p>\n<p>虐狗文《从你的全世界悔过》<a href=\"https://cnodejs.org/topic/59a4102d9e95202d08c91d45%EF%BC%8C%E6%AD%A4%E6%96%87%E6%98%AF%E4%B8%83%E5%A4%95%E6%97%B6%E7%BB%99%E5%AA%B3%E5%A6%87%E5%86%99%E7%9A%84%E8%AF%97%E6%AD%8C%E4%B8%B2%E8%B5%B7%E6%9D%A5%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E5%BE%88%E5%A4%9A%E4%BA%BA%E8%AF%B4%E8%AF%BB%E4%BA%86%E8%BF%98%E6%8C%BA%E6%84%9F%E5%8A%A8%EF%BC%8C%E7%9F%A5%E4%B9%8E%E4%B8%8A%E4%B9%9F%E6%94%B6%E8%8E%B7%E4%B8%8D%E5%B0%91%E8%B5%9E%E3%80%82%E8%AF%97%E6%AD%8C%E5%B0%B1%E4%B8%8D%E5%B8%96%E4%BA%86%EF%BC%8C%E6%9D%A5%E4%B8%80%E5%B0%8F%E6%AE%B5%E8%8A%82%E9%80%89%E3%80%82\">https://cnodejs.org/topic/59a4102d9e95202d08c91d45，此文是七夕时给媳妇写的诗歌串起来的一篇文章，很多人说读了还挺感动，知乎上也收获不少赞。诗歌就不帖了，来一小段节选。</a></p>\n<p>“喜欢一个人就是喜欢，不需要什么理由，你看到她第一眼的时候，就知道这个女人会注定陪我一生。我们也没什么物质追求，只是简简单单的，在一起，很开心，想结婚，想和她过一辈子。</p>\n<p>很多人都知道我的网名是i5ting，这里的ting就是她，张婷的婷！我在很多公众场合都是这样自我介绍的：“大家好，我是i5ting，婷是我媳妇的名字”，然后大家就笑了。”</p>\n<h2>组织的活动</h2>\n<ul>\n<li>2017年7月29日 北京Node Party活动 <a href=\"https://cnodejs.org/topic/597edd7f8f0313ff0d08d97a\">https://cnodejs.org/topic/597edd7f8f0313ff0d08d97a</a></li>\n<li>2017年3月30日 饿了么前端团队来访去哪儿网 <a href=\"http://www.sohu.com/a/130839117_505779\">http://www.sohu.com/a/130839117_505779</a></li>\n</ul>\n<p>北京Node Party活动本想在年再举办一次，奈何太忙，放到2018吧。</p>\n<h2>付费学习</h2>\n<ul>\n<li>狼叔：如何正确学习 Node.js？<a href=\"https://www.zhihu.com/lives/928687583372926976\">https://www.zhihu.com/lives/928687583372926976</a></li>\n<li>StuQ组织的Live：大前端和 Node.js 那些事  <a href=\"https://www.zhihu.com/lives/802472054787043328\">https://www.zhihu.com/lives/802472054787043328</a></li>\n<li>Node.js异步流程控制概览与最新的async/await  <a href=\"https://segmentfault.com/l/1500000008716683?_ea=3127449\">https://segmentfault.com/l/1500000008716683?_ea=3127449</a></li>\n<li>白干一年半的被坑的CTO <a href=\"https://segmentfault.com/l/1500000008716621\">https://segmentfault.com/l/1500000008716621</a></li>\n<li>深入浅出浏览器渲染原理 <a href=\"http://gitbook.cn/gitchat/activity/59014652fe6a6f3bdac9c49b\">http://gitbook.cn/gitchat/activity/59014652fe6a6f3bdac9c49b</a></li>\n<li>聊聊 Node.js 的历史http://gitbook.cn/gitchat/activity/58d6887577508ce666dbdf35</li>\n<li>发一个小密圈《狼叔爱Node》，有兴趣的一起来玩  <a href=\"https://cnodejs.org/topic/58afb00f7872ea0864fee070%EF%BC%8C%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%8A%9E%E6%B3%95%EF%BC%8C%E5%85%B3%E6%B3%A8nodeonly%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%8C%E8%8F%9C%E5%8D%95%E9%87%8C%E5%8D%B3%E5%8F%AF%E5%8A%A0%E5%85%A5%EF%BC%8C%E5%89%8D100%E5%90%8D99%E5%85%83/%E5%B9%B4%EF%BC%8C%E4%B9%8B%E5%90%8E%E6%81%A2%E5%A4%8D%E6%AD%A3%E5%B8%B8%E4%BB%B7%E6%A0%BC199%E5%85%83/%E5%B9%B4\">https://cnodejs.org/topic/58afb00f7872ea0864fee070，另外一种办法，关注nodeonly公众号，菜单里即可加入，前100名99元/年，之后恢复正常价格199元/年</a></li>\n</ul>\n<h2>诗歌</h2>\n<p>个人诗集《春天的恐惧症》已付梓，由上海文艺出版社出版，168页，由著名诗人破破作序《物质时代的草甸之子》，在知乎上回复了《程序员可以培养的第二技能有哪些？》<a href=\"https://www.zhihu.com/question/264575890/answer/291053439\">https://www.zhihu.com/question/264575890/answer/291053439</a></p>\n<pre class=\"prettyprint\"><code>\n【很多人说写作，我想说你们那是码字。能高雅点么？】\n</code></pre><p>今年诗歌写的少，只有20多首。</p>\n<ul>\n<li>我的2017年总结</li>\n<li>在22楼</li>\n<li>儿子</li>\n<li>星空漫想</li>\n<li>好先生第三十五集观后感</li>\n<li>《补身份证记》</li>\n<li>我来的时候风景正好</li>\n<li>谁说相见不如倾慕</li>\n<li>节日</li>\n<li>行走在阳光下</li>\n<li>书签</li>\n<li>相聚与相遇</li>\n<li>媳妇发来宝宝的视频</li>\n<li>从你的全世界悔过</li>\n<li>春天的中午</li>\n<li>大米</li>\n<li>静静地看着他</li>\n<li>梦魇</li>\n<li>无题</li>\n<li>烟囱与婴儿</li>\n<li>初冬，一个干活的人</li>\n</ul>\n<p>《补身份证记》的后2章节可为很精彩，很多人都非常喜欢。我是很不满的情绪，大概可见一斑。</p>\n<pre class=\"prettyprint\"><code>这事儿也是有好处的\n今天去厕所，无纸\n一摸兜，一打还没来得及扔的临时证明\n不就是一打纸吗?\n虽然有点硬\n虽然只有巴掌大小\n我把大头照片一一取下\n向辉煌抹去\n\n\n那一刹那\n我竟还忍不住感动\n临时身份证上，姓名和身份证号码\n深深地印在屁股上\n</code></pre><p>其实，我个人最喜欢的诗歌是《星空漫想》。缺少的在补，想要的在继续。不知道能有多少人能够理解30岁之后的感谢。其实有很多人跟我一样。</p>\n<pre class=\"prettyprint\"><code>《星空漫想》\n\n像量天尺一样，鼓起勇气\n向夜晚迈出大大的一步\n我知道，离星空还远\n我只是想给未来一个大大的拥抱\n\n像烟花一样，一飞冲天\n燃烧，绚烂，哪怕变成一缕青烟\n我知道，生命和星星一样，可望而不可及\n只能努力的，不错过每一颗\n\n不知道自己拥有什么\n也不知道自己想要什么\n仿佛一切，只是向死而生\n我们站在星空下，无限渺小\n\n其实你还是你，夜还是夜，星空还是星空\n缺少的在补，想要的在继续\n在无限的找寻中，一直都是自己与快乐斗争\n散落星空的战友，像极了无数个自己\n</code></pre><h2>总结</h2>\n<p>最后用《我的2017年总结》来结尾吧，元旦当晚，我和妻儿一起看电视，吃橘子，感慨一年过往。诗歌写的像故事一样，对比情景，还是比较温暖的。</p>\n<pre class=\"prettyprint\"><code>这一年特别快\n孩子已经快一岁了\n我也出去了一年\n许多心酸许多感谢\n\n她觉得慢\n她只做了一件事儿\n照顾孩子，辛苦更多\n感恩更多\n\n媳妇给孩儿扒橘子\n将橘子皮扒开\n将橘子肉分几次\n送到孩子嘴里\n\n我给媳妇扒橘子\n直接送她嘴里\n宝宝拍拍我的肩\n一定是嫌我送的快了\n</code></pre><h2>预告</h2>\n<h3>极客时间App上，即将发表《Node.js全栈2018前瞻》专题</h3>\n<p>写这篇文章的原因是在2017年，我写了一篇<a href=\"https://cnodejs.org/topic/58eee565a92d341e48cfe7fc\">《2017，我们来聊聊 Node.js》</a>，单篇阅读量将近9万，效果还是相当不错的。但很多科普工作做的还不够好，比如在2017年底，被某些喷子在知乎上黑Node.js，当时我虽然回了一篇<a href=\"https://cnodejs.org/topic/5a328967d92f2f5b185ace96\">狼叔回复的《Node相比传统服务端技术栈好在哪里？》</a>，但还是深感焦虑，很多人对Node.js理解的是不太正确的。</p>\n<p>比如常见问题</p>\n<ul>\n<li>Node.js是js语法，能不能像java一样大规模开发？</li>\n<li>Node.js适不适合写后端？</li>\n<li>Node.js异步写法太麻烦，回调太恶心。。。</li>\n<li>Node.js性能到底和go相比如何，我要不要转go？</li>\n<li>前端技术发展那么快，我该怎么应变？</li>\n</ul>\n<p>故而，我打算在本篇文章里把2018年以Node.js为中心的主流趋势科普一下。希望为Node.js正名尽微薄之力。</p>\n<p>大纲</p>\n<ol>\n<li>Node.js2017回顾和2018概览</li>\n<li>不要异步，我们要同步流程控制：Async函数和更好的ES6模块模块</li>\n<li>类型系统和面向对象的完美es6超集：TypeScript &amp;&amp; flow &amp;&amp; coffee</li>\n<li>大前端、工程化与AI时代应变：Webpack &amp;&amp; Weex &amp; Electron</li>\n<li>日渐成熟的Node.js企业级Web开发框架：Strongloop、Eggjs、Thinkjs</li>\n<li>Node.js生态、架构演进和商业案例再思考</li>\n</ol>\n<h3>【知乎Live】狼叔：如何正确的学习Node.js</h3>\n<p>Live 简介\n你好，我是 i5ting ，江湖人称「狼叔」，目前是阿里巴巴技术专家，斯达克学院（ StuQ ）明星讲师， Node.js 技术布道者。曾就职于去哪儿、新浪、网秦，做过前端、后端、数据分析，是一名全栈技术的实践者。</p>\n<p>现在，越来越多的科技公司和开发者开始使用 Node.js 开发各种应用。Node.js除了能够辅助大前端开发外，还可以编写Web应用，封装Api，组装RPC服务等，甚至是开发VSCode编辑器一样的PC客户端。和其它技术相比， Node.js 简单易学，性能好、部署容易，能够轻松处理高并发场景下的大量服务器请求。Node.js 周边的生态也非常强大，NPM（Node包管理）上有超过60万个模块，日下超过载量3亿次。但编写 Node.js 代码对新人和其它语言背景的开发者来说，不是一件容易的事，在入门之前需要弄懂不少复杂的概念。</p>\n<p>我身边也有很多人问我：如何学习 Node.js ？作为一名 Node.js 布道者，我做过很多 Node.js 普及和推广的工作，对它的基本概念和核心模块都很熟悉； 此外，我还在撰写一本名为《更了不起的 Node.js 》的书，已经写了 2 年，积累了很丰富的资料，本次 Live 也将为你提供对 Node.js 更全面的解读。</p>\n<p>本次 Live 主要包括以下内容</p>\n<ol>\n<li>前言：学习 Node.js 的三个境界</li>\n<li>准备：\n<ul>\n<li>Node 用途那么多，我该从哪里学起？</li>\n<li>Node Web 框架那么多，我该怎么选？</li>\n<li>关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n</li>\n<li>延伸：大前端变化那么快，如何才能做到每日精进？</li>\n<li>实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</li>\n<li>答疑：回答大家的问题</li>\n</ol>\n<p>本次Live主要是科普，适用新用户和比较迷茫的Node朋友，参加地址</p>\n<p><a href=\"https://www.zhihu.com/lives/928687583372926976\">https://www.zhihu.com/lives/928687583372926976</a></p>\n<p>时间是明天晚上哦</p>\n</div>","title":"我的2017年总结","last_reply_at":"2018-01-20T07:17:14.782Z","good":false,"top":false,"reply_count":3,"visit_count":462,"create_at":"2018-01-19T12:34:32.687Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"5a62c7face45d440451461a7","author_id":"56f3c9699f24439945cd3f32","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://www.jianshu.com/p/a72150138cd7\">问题介绍引自Python版本</a></p>\n<h2>题目描述</h2>\n<p>看下面这个图片，在这个图片里我们有不同高度的墙。这个图片由一个整数数组所代表，数组中每个数是墙的高度。上边的图可以表示为数组[2,5,1,2,3,4,7,7,6]，假如开始下雨了，那么墙之间的水坑能够装多少水呢？”</p>\n<p>以1×1的方块为单位计算容积。所以，在上边的图中下标为1以左的都会漏掉。下标7以右的也会漏掉。剩下的只有在1和6之间的一坑水，容积是10。如下图所示。</p>\n<h2>分析</h2>\n<p>原文作者最初想法是用极大值考虑，也就是说找到下标2的左右两个极大值，但是这个做法最后作者意识到是错误的。比如下面的情况就不对：\n看看这个输入：</p>\n<p><img src=\"//dn-cnode.qbox.me/Fv5ZblJkhMKOQZ62k86YAXkKwec_\" alt=\"286774-7d71e9846e42fe3c.jpg\"></p>\n<p>如果答案计算的是极大值之间的水，就像这样。</p>\n<p><img src=\"//dn-cnode.qbox.me/FiSpEY7lGboIBs5EeQKIT9Jdsp7f\" alt=\"286774-0477dab12c584826.jpg\"></p>\n<p>但是答案应该是在两个高塔之间只有一池水：\n<img src=\"//dn-cnode.qbox.me/FgnDgoLYd2yc5ylJt8AMy3tdpFzr\" alt=\"286774-b9c4ef8f7288573e.jpg\">\n那其实正确的解法是作者后来灵光一闪想到的，确实看起来很简单。这其实要基于一个事实那就是，你从左往右扫描数组的时候，只要是左边最大值小于右边的数字时，这中间是一定可以存储水的。每次维护一个左墙的最大值，从左向右的扫描过程中遇到大于左边最大值的值，则更新左边最大值，并且不增加存储水的容量，因为在从左往右扫描的过程中，如果遇到的值比左边大，那么存储不了水，如上面例子中从2开始扫描，遇到5的时候，此时存储容量还是0，因为5大于2，这中间存储不了水。从右往左扫描也是一样。\n一个基本的解法就是先找到数组最大值，然后从左往右扫描到最大值，计算出水的容量；然后从右往左扫描到最大值，计算出水的容量，最后总的容量就是两部分之和。</p>\n<p>描述还是会不怎么清楚，还是以例子来看。以第一个例子[2,5,1,2,3,4,7,7,6]来看，最大值为7，两个7随便选后面一个好了。那么从左往右扫描过程如下：</p>\n<p>1）首先设置左边最大值为2,容量设置为0。\n2）2小于7，往右继续扫描，遇到5，因为5大于2，所以更新左边最大值为5，此时并不更新存储水的容量，接着往后扫描。\n3）扫描到1,因为1比前面的5小，因此现在至少可以存储5-1=4单位水。存储水的容量加4。因为我们知道右边有比左边最大值还大的值，所以肯定是可以至少存储这么多水的。\n4）接着扫描到2，还是比5小，存储水的容量增加5-2=3，容量变为4+3=7.\n5）继续扫描到3，还是比5小，存储水的容量增加5-3=2，容量变为7+2=9.\n6）继续扫描到4，还是比5小，存储水的容量增加5-4=1，容量变为9+1=10.\n可以得到左侧存储水的容量为10。同理，从右往左扫描到7，容量为0，因为6小于7，7以右的水全部会漏掉。\n那么一个更优的解法其实是只需要扫描一遍就OK，不需要之前扫描数组找最大值，也就是整合了左右扫描的过程。如果左边值小于右边值，则从左往右扫描，否则从右往左扫描。）</p>\n<h2>直接上代码</h2>\n<pre class=\"prettyprint\"><code>let calculate = function(arry) {\n    let max = [arry.shift(), arry.pop()]; &#x2F;&#x2F; 0 最左 1 最右\n    let result = 0; &#x2F;&#x2F; 结果\n\n    while (arry.length &gt; 0) {\n        \n        &#x2F;&#x2F; 从最小的一边遍历，取值结果小与最值则累加，大于最值则同步最值\n        let short = max[0] &lt; max[1] ? 0 : 1,\n            current = short ? arry.pop() : arry.shift();\n\n        if (current &gt; max[short])\n            max[short] = current;\n        else\n            result += max[short] - current;\n    }\n\n    return result;\n}\n</code></pre></div>","title":"twitter面试题之装水问题:NodeJS版本","last_reply_at":"2018-01-20T07:01:23.264Z","good":false,"top":false,"reply_count":1,"visit_count":208,"create_at":"2018-01-20T04:39:22.251Z","author":{"loginname":"miwoy","avatar_url":"https://avatars0.githubusercontent.com/u/6166336?v=4&s=120"}},{"id":"5a62b395afa0a121784a8de0","author_id":"590d7e623504ce1c2ac45912","tab":"share","content":"<div class=\"markdown-text\"><h2>JavaScript 中基础数据类型</h2>\n<table>\n<thead>\n<tr>\n<th>数据类型名称</th>\n<th>数据类型说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Undefined</td>\n<td>只有一个值，即 <code>undefined</code>，声明变量的初始值。</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>只有一个值，即 <code>null</code>，表示空指针，<code>undefined</code> 的值是派生 <code>null</code> 的值。</td>\n</tr>\n<tr>\n<td>String</td>\n<td>由零或多个 16 位 <code>Unicode</code> 字符组成</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>只有两个值，即 <code>true</code> 和 <code>false</code></td>\n</tr>\n<tr>\n<td>Number</td>\n<td>该类型使用 <code>IEEE754</code> 来表示整数和浮点数。</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>ECMAScript 中的对象其实就是一组数据和功能的集合。</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>ES6 中新加入的数据类型，表示独一无二的值。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>其中 <code>Object</code> 类型包含 <code>Function</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code>。</strong></p>\n<h2>JavaScript 中的内置对象</h2>\n<table>\n<thead>\n<tr>\n<th>对象名称</th>\n<th>对象说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Arguments</td>\n<td>函数参数集合</td>\n</tr>\n<tr>\n<td>Array</td>\n<td>数组</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>布尔对象</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>日期对象</td>\n</tr>\n<tr>\n<td>Error</td>\n<td>异常对象</td>\n</tr>\n<tr>\n<td>Function</td>\n<td>函数构造器</td>\n</tr>\n<tr>\n<td>Math</td>\n<td>数学对象</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>数值对象</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>基础对象</td>\n</tr>\n<tr>\n<td>String</td>\n<td>字符串对象</td>\n</tr>\n</tbody>\n</table>\n<h2><code>typeof null</code> 返回结果为 <code>'object'</code></h2>\n<p>  从逻辑上来看，<code>null</code> 值表示一个空对象指针，因此会返回一个 <code>'object'</code>，也可以理解为是 JavaScript 早期的一个BUG，而现在标准就是这样规范的。V8曾经修正并实现过<code>typeof null === 'null'</code>,但最终证明不可行。<a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null\">http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null</a></p>\n<h2><code>Array</code> 对象方法与作用</h2>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>对象说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>concat</td>\n<td>用于连接两个或更多的数组并返回结果,<code>arr1.concat(arr2)</code></td>\n</tr>\n<tr>\n<td>join</td>\n<td>把数组的所有元素放入一个字符串，元素通过制定的分隔符进行分离 <code>arr1.join(',')</code></td>\n</tr>\n<tr>\n<td>pop</td>\n<td>删除并返回数组中的最后一个元素 <code>arr1.pop()</code></td>\n</tr>\n<tr>\n<td>push</td>\n<td>向数组的末尾添加一个或更多元素，并返回新的长度 <code>arr1.push(1)</code></td>\n</tr>\n<tr>\n<td>reverse</td>\n<td>颠倒数组中的元素顺序,<code>arr1.reverse()</code></td>\n</tr>\n<tr>\n<td>shift</td>\n<td>删除并返回数组中的第一个元素  <code>arr1.shift()</code></td>\n</tr>\n<tr>\n<td>slice</td>\n<td>从某个已有的数组返回指定的元素</td>\n</tr>\n<tr>\n<td>sort</td>\n<td>对数组的元素进行排序 <code>arr1.sort()</code></td>\n</tr>\n<tr>\n<td>splice</td>\n<td>删除元素，并向数组中添加新元素</td>\n</tr>\n<tr>\n<td>toString</td>\n<td>把数组转成字符串 <code>arr1.toString()</code></td>\n</tr>\n<tr>\n<td>toLocaleString</td>\n<td>把数组转换为本地字符串 <code>arr1.toLocaleString()</code></td>\n</tr>\n<tr>\n<td>valueOf</td>\n<td>返回数组对象的原始值</td>\n</tr>\n</tbody>\n</table>\n<h2><code>typeof</code> 可能的返回值</h2>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>返回结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Undefined</td>\n<td>“undefined”</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>“object”</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>“boolean”</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>“number”</td>\n</tr>\n<tr>\n<td>String</td>\n<td>“string”</td>\n</tr>\n<tr>\n<td>Symbol （ECMAScript 6 新增）</td>\n<td>“symbol”</td>\n</tr>\n<tr>\n<td>宿主对象（由JS环境提供）</td>\n<td>Implementation-dependent</td>\n</tr>\n<tr>\n<td>函数对象（[[Call]] 在ECMA-262条款中实现了）</td>\n<td>“function”</td>\n</tr>\n<tr>\n<td>任何其他对象</td>\n<td>“object”</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>上述来自 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof\">MDN</a></p>\n</blockquote>\n<p>对文章有不正确之处，请给予纠正。<a href=\"https://github.com/SilenceHVK/articles/issues/16\">github 文章</a> 请顺手给个 Star，最后感谢您的阅读。</p>\n</div>","title":"【JavaScript 基础知识】一篇关于 JavaScript 一些知识点的总结 —— 持续更新","last_reply_at":"2018-01-20T03:12:21.593Z","good":false,"top":false,"reply_count":0,"visit_count":170,"create_at":"2018-01-20T03:12:21.593Z","author":{"loginname":"SilenceHVK","avatar_url":"https://avatars3.githubusercontent.com/u/12862565?v=4&s=120"}},{"id":"5a625bfece45d440451461a0","author_id":"5a4edbe8ebc575dc49b27157","tab":"share","content":"<div class=\"markdown-text\"><p>Understanding The React Source Code — Initial Rendering (Class Component) V （英文预览版）</p>\n<p><a href=\"http://holmeshe.me/understanding-react-js-source-code-initial-rendering-V/\">http://holmeshe.me/understanding-react-js-source-code-initial-rendering-V/</a></p>\n<p>本文同时发表在<a href=\"https://hackernoon.com/understanding-the-react-source-code-v-812d69a79fb9\">Hackernoon</a>，打得开的话帮忙在Medium上点个赞吧！</p>\n</div>","title":"深入理解React源码 V (英文)","last_reply_at":"2018-01-20T01:35:16.851Z","good":false,"top":false,"reply_count":1,"visit_count":146,"create_at":"2018-01-19T20:58:38.866Z","author":{"loginname":"holmeshe","avatar_url":"https://avatars3.githubusercontent.com/u/30769400?v=4&s=120"}}]};

export default data;